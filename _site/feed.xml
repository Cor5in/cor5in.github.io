<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2025-01-30T17:26:11+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Geon Kim</title><subtitle>Hydejack is a boutique Jekyll theme for hackers, nerds, and academics, with a focus on personal sites that are meant to impress.
</subtitle><author><name>&lt;firstname&gt; &lt;lastname&gt;</name><email>&lt;mail@domain.tld&gt;</email></author><entry><title type="html">A Base Station Sleeping Strategy in Heterogeneous Cellular Networks Based on User Traffic Prediction</title><link href="http://localhost:4000/blog/paper/2025-01-15-a-basestation-sleeping-strategy-in-heterogeneous-cellular-networks-based-on-user-traffic-prediction/" rel="alternate" type="text/html" title="A Base Station Sleeping Strategy in Heterogeneous Cellular Networks Based on User Traffic Prediction" /><published>2025-01-15T00:00:00+09:00</published><updated>2025-01-15T00:00:00+09:00</updated><id>http://localhost:4000/blog/paper/a-basestation-sleeping-strategy-in-heterogeneous-cellular-networks-based-on-user-traffic-prediction</id><content type="html" xml:base="http://localhost:4000/blog/paper/2025-01-15-a-basestation-sleeping-strategy-in-heterogeneous-cellular-networks-based-on-user-traffic-prediction/"><![CDATA[<!--more-->
<ul class="large-only" id="markdown-toc">
  <li><a href="#abstract" id="markdown-toc-abstract">Abstract</a></li>
  <li><a href="#논문의-구조" id="markdown-toc-논문의-구조">논문의 구조</a></li>
  <li><a href="#1-why-this-paper" id="markdown-toc-1-why-this-paper">1. Why this paper</a>    <ul>
      <li><a href="#11-what-is-the-research-topic-and-why-was-it-chosen" id="markdown-toc-11-what-is-the-research-topic-and-why-was-it-chosen">1.1 What is the research topic and why was it chosen?</a></li>
      <li><a href="#12-what-are-the-objectives-of-the-study" id="markdown-toc-12-what-are-the-objectives-of-the-study">1.2 What are the objectives of the study?</a></li>
      <li><a href="#13-what-methods-were-used-to-conduct-the-research" id="markdown-toc-13-what-methods-were-used-to-conduct-the-research">1.3 What methods were used to conduct the research?</a></li>
      <li><a href="#14-what-results-were-obtained" id="markdown-toc-14-what-results-were-obtained">1.4 What results were obtained?</a></li>
      <li><a href="#15-what-is-the-significance-of-the-results" id="markdown-toc-15-what-is-the-significance-of-the-results">1.5 What is the significance of the results?</a></li>
    </ul>
  </li>
  <li><a href="#2-paper-summarization" id="markdown-toc-2-paper-summarization">2. Paper Summarization</a>    <ul>
      <li><a href="#21-introduction" id="markdown-toc-21-introduction">2.1 Introduction</a></li>
      <li><a href="#22-related-work" id="markdown-toc-22-related-work">2.2 Related Work</a></li>
      <li><a href="#23-system-model" id="markdown-toc-23-system-model">2.3 System Model</a>        <ul>
          <li><a href="#231-네트워크-구성" id="markdown-toc-231-네트워크-구성">2.3.1 네트워크 구성</a></li>
          <li><a href="#232-트래픽-예측-모델" id="markdown-toc-232-트래픽-예측-모델">2.3.2 트래픽 예측 모델</a></li>
          <li><a href="#233-sinr-모델" id="markdown-toc-233-sinr-모델">2.3.3 SINR 모델</a>            <ul>
              <li><a href="#2331-기지국-유형-정의-thetai" id="markdown-toc-2331-기지국-유형-정의-thetai">2.3.3.1 기지국 유형 정의 (\(\theta(i)\))</a></li>
              <li><a href="#2332-경로-손실-모델-l_ik" id="markdown-toc-2332-경로-손실-모델-l_ik">2.3.3.2 경로 손실 모델 (\(L_{i,k}\))</a></li>
              <li><a href="#2333-sinr-계산-s_i-k" id="markdown-toc-2333-sinr-계산-s_i-k">2.3.3.3 SINR 계산 (\(S_{i, k}\))</a></li>
            </ul>
          </li>
          <li><a href="#234-bs-전력-소비-모델" id="markdown-toc-234-bs-전력-소비-모델">2.3.4 BS 전력 소비 모델</a>            <ul>
              <li><a href="#2341-사용자-요구-대역폭-계산" id="markdown-toc-2341-사용자-요구-대역폭-계산">2.3.4.1 사용자 요구 대역폭 계산</a></li>
              <li><a href="#2342-기지국-부하-계산" id="markdown-toc-2342-기지국-부하-계산">2.3.4.2 기지국 부하 계산</a></li>
              <li><a href="#2343-기지국-전력-소비-모델" id="markdown-toc-2343-기지국-전력-소비-모델">2.3.4.3 기지국 전력 소비 모델</a></li>
              <li><a href="#235-blstm-모델" id="markdown-toc-235-blstm-모델">2.3.5 BLSTM 모델</a></li>
            </ul>
          </li>
          <li><a href="#24-문제-정의" id="markdown-toc-24-문제-정의">2.4 문제 정의</a>            <ul>
              <li><a href="#241-변수-정의" id="markdown-toc-241-변수-정의">2.4.1 변수 정의</a></li>
              <li><a href="#242-최적화-목표" id="markdown-toc-242-최적화-목표">2.4.2 최적화 목표</a></li>
            </ul>
          </li>
          <li><a href="#25-proposed-milsf-strategy" id="markdown-toc-25-proposed-milsf-strategy">2.5 Proposed MiLSF Strategy</a>            <ul>
              <li><a href="#251-알고리즘-목표" id="markdown-toc-251-알고리즘-목표">2.5.1 알고리즘 목표</a></li>
              <li><a href="#252-알고리즘-절차" id="markdown-toc-252-알고리즘-절차">2.5.2 알고리즘 절차</a>                <ul>
                  <li><a href="#step-1-초기화" id="markdown-toc-step-1-초기화">Step 1. 초기화</a></li>
                </ul>
              </li>
              <li><a href="#step-2-mibs-부하-정렬" id="markdown-toc-step-2-mibs-부하-정렬">Step 2. MiBS 부하 정렬</a></li>
              <li><a href="#step-3-절전-가능-여부-평가" id="markdown-toc-step-3-절전-가능-여부-평가">Step 3. 절전 가능 여부 평가</a>                <ul>
                  <li><a href="#1-mibs-i의-사용자를-인접한-활성-기지국으로-재배치" id="markdown-toc-1-mibs-i의-사용자를-인접한-활성-기지국으로-재배치">1. MiBS \(i\)의 사용자를 인접한 활성 기지국으로 재배치</a></li>
                  <li><a href="#2-제약-조건-확인" id="markdown-toc-2-제약-조건-확인">2. 제약 조건 확인</a></li>
                  <li><a href="#3-조건이-만족되면-mibs-i를-절전-상태로-전환" id="markdown-toc-3-조건이-만족되면-mibs-i를-절전-상태로-전환">3. 조건이 만족되면 MiBS \(i\)를 절전 상태로 전환</a></li>
                  <li><a href="#4-조건이-만족되지-않으면-mibs-i는-활성-상태-유지" id="markdown-toc-4-조건이-만족되지-않으면-mibs-i는-활성-상태-유지">4. 조건이 만족되지 않으면 MiBS \(i\)는 활성 상태 유지</a></li>
                </ul>
              </li>
              <li><a href="#step-4-반복" id="markdown-toc-step-4-반복">Step 4: 반복</a></li>
              <li><a href="#253-알고리즘-종료-조건" id="markdown-toc-253-알고리즘-종료-조건">2.5.3 알고리즘 종료 조건</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#numerical-results" id="markdown-toc-numerical-results">Numerical Results</a>        <ul>
          <li><a href="#실험-목표" id="markdown-toc-실험-목표">실험 목표</a></li>
          <li><a href="#blstm-트래픽-예측-성능" id="markdown-toc-blstm-트래픽-예측-성능">BLSTM 트래픽 예측 성능</a>            <ul>
              <li><a href="#실험-설정" id="markdown-toc-실험-설정">실험 설정</a></li>
              <li><a href="#결과-요약" id="markdown-toc-결과-요약">결과 요약</a></li>
            </ul>
          </li>
          <li><a href="#milsf-알고리즘-성능" id="markdown-toc-milsf-알고리즘-성능">MiLSF 알고리즘 성능</a>            <ul>
              <li><a href="#실험-설정-1" id="markdown-toc-실험-설정-1">실험 설정</a></li>
              <li><a href="#결과-요약-1" id="markdown-toc-결과-요약-1">결과 요약</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#future-work" id="markdown-toc-future-work">Future Work</a></li>
    </ul>
  </li>
  <li><a href="#3-take-away" id="markdown-toc-3-take-away">3. Take Away</a></li>
</ul>

<h1 id="abstract">Abstract</h1>

<p>셀룰러 네트워크의 실시간 트래픽은 시간에 따라 변하며, 주간/야간과 같은 tide 패턴을 보임. 이 특성을 활용하여 네트워크 전반에 분산된 작업 부하를 소수의 기지국으로 통합하여 에너지 소비를 줄일 수 있음. 본 연구는 Macro 기지국과 Micro 기지국으로 구성된 2단계 HetNet을 대상으로 기지국 절전 전략을 제안함. BLSTM(Bidirectional Long Short-Term Memory)을 이용하여 각 사용자의 미래 트래픽을 예측하고, 이를 기반으로 MiBS의 절전 및 User association 재배치를 수행함. Micro 기지국은 항상 활성 상태를 유지하며, 사용자 서비스 품질은 SINR 임계값을 준수하도록 보장함.</p>

<hr />

<h1 id="논문의-구조">논문의 구조</h1>

<ol>
  <li>Introduction</li>
  <li>Related Work</li>
  <li>System Model</li>
  <li>Problem Formulation</li>
  <li>Proposed MiLSF Strategy</li>
  <li>Numerical Results</li>
  <li>Conclusion</li>
</ol>

<hr />

<h1 id="1-why-this-paper">1. Why this paper</h1>

<ol>
  <li>SKT 트래픽 예측 논문 레퍼런스 조사</li>
  <li>트래픽 예측을 통한 Cell on/off</li>
</ol>

<h2 id="11-what-is-the-research-topic-and-why-was-it-chosen">1.1 What is the research topic and why was it chosen?</h2>

<ul>
  <li><strong>연구 주제</strong>: HetNet에서 사용자 트래픽 예측을 활용한 에너지 절감 전략</li>
  <li><strong>선택 이유</strong>
    <ul>
      <li>트래픽의 급격한 증가로 네트워크 에너지 소비가 크게 증가함</li>
      <li>에너지 소비를 줄이는 것은 운영 비용 절감과 온실가스 배출 감소를 위해 매우 중요함</li>
    </ul>
  </li>
</ul>

<h2 id="12-what-are-the-objectives-of-the-study">1.2 What are the objectives of the study?</h2>

<ul>
  <li>낮은 부하 시간대에 기지국 절전 전략을 개발하여 이종 셀룰러 네트워크의 에너지 소비를 줄이는 것</li>
  <li>BLSTM(Bidirectional Long Short-Term Memory) 신경망을 활용하여 사용자별 트래픽 수요를 정확히 예측</li>
  <li>모든 사용자의 QoS를 유지하며, 사전에 정의된 SINR(신호 대 간섭 잡음비) 임계값을 충족하도록 보장</li>
</ul>

<h2 id="13-what-methods-were-used-to-conduct-the-research">1.3 What methods were used to conduct the research?</h2>

<ul>
  <li>트래픽 예측: BLSTM 신경망을 사용해 과거 트래픽 데이터를 기반으로 사용자별 미래 트래픽을 예측</li>
  <li>네트워크 모델링: HetNet을 Macro BS와 Micro BS로 구성된 2단계 네트워크로 모델링하고, 기지국 위치를 PPP와 MHCPP로 시뮬레이션</li>
  <li>제안된 전략: MiLSF(Minimum Load Sleep First) 전략을 개발하여 부하가 적은 MiBS를 우선적으로 절전 모드로 전환하고, 사용자를 활성 기지국으로 재배치</li>
  <li>시뮬레이션: 다양한 배치 시나리오와 네트워크 조건에서 MiLSF와 기존 절전 전략 4가지를 비교 분석</li>
</ul>

<h2 id="14-what-results-were-obtained">1.4 What results were obtained?</h2>

<ul>
  <li>MiLSF는 기존 4가지 전략(Randomly Sleep, Randomly Reallocate Users, Clsest User Reallocation, Closest Base Station Sleep First)보다 모든 시나리오에서 우수한 에너지 절약 성과를 보임</li>
  <li>MHCPP를 활용한 기지국 배치가 PPP보다 높은 에너지 절약 효과를 가져옴</li>
  <li>중간 수준의 사용자 트래픽 부하와 적당한 SINR 임계값에서 에너지 절약 효과가 극대화됨</li>
  <li>MiLSF는 사용자를 효과적으로 재배치하여 더 많은 MiBS를 절전 모드로 전환할 수 있었음</li>
</ul>

<h2 id="15-what-is-the-significance-of-the-results">1.5 What is the significance of the results?</h2>

<ul>
  <li><strong>에너지 효율성</strong>: HetNet에서 에너지 소비를 효과적으로 줄이는 실질적이고 실현 가능한 방법 제시</li>
  <li><strong>서비스 품질 보장</strong>: 에너지 절약과 사용자 QoS 동시에 달성</li>
  <li><strong>연구 기여</strong>: AI 기반 트래픽 예측과 에너지 효율적 네트워크 운영 전략의 통합 가능성을 제시하여 관련 연구를 발전시킴</li>
</ul>

<hr />

<h1 id="2-paper-summarization">2. Paper Summarization</h1>

<h2 id="21-introduction">2.1 Introduction</h2>

<ul>
  <li><strong>연구 배경</strong>: 모바일 기기와 데이터 트래픽의 증가로 셀룰러 네트워크 에너지 소비 증가. 기지국이 네트워크 에너지 소비의 80% 이상 차지</li>
  <li><strong>문제점</strong>: 기존 네트워크는 에너지 효율성이 낮으며, 사용자 QoS를 유지하면서 에너지 소비를 줄이는 방법이 필요</li>
  <li><strong>제안 내용</strong>: BLSTM 기반 트래픽 예측을 통해 사용자별 트래픽을 분석하고, MiBS를 절전 상태로 전환하는 MiLSF 전략을 제안</li>
  <li><strong>목표</strong>: 에너지 소비 감소와 서비스 품질 유지</li>
</ul>

<h2 id="22-related-work">2.2 Related Work</h2>

<ul>
  <li><strong>에너지 절감 HeCN 연구</strong>: MiBS를 활용한 네트워크 효율성 개선 방안 연구</li>
  <li><strong>트래픽 예측</strong>: ARIMA, RNN, LSTM 등 다양한 모델 사용. BLSTM은 특히 시간 종속성을 잘 학습하여 높은 예측 정확도를 제공</li>
  <li><strong>기지국 절전 전략</strong>: 사용자 할당 및 네트워크 부하 분산을 고려한 절전 방식 연구. 기존 연구는 BS 트래픽 예측에 초점, 사용자별 요구를 반영하지 못함</li>
</ul>

<h2 id="23-system-model">2.3 System Model</h2>

<h3 id="231-네트워크-구성">2.3.1 네트워크 구성</h3>
<ul>
  <li>구조: 이종 셀룰러 네트워크(HeCN)는 Macro BS(MaBS)와 Micro BS(MiBS)으로 구성
    <ul>
      <li>MaBS: 넓은 영역 커버리지, 높은 송신 전력, 항상 활성 상태 유지</li>
      <li>MiBS: 좁은 영역 커버리지, 낮은 송신 전력, 부하에 따라 절전 가능</li>
    </ul>
  </li>
</ul>

<p align="center">
  <img src="/assets/img/blog/0115/fig/fig.1.1.png" alt="Left Image" width="45%" style="margin-right: 10px;" />
  <img src="/assets/img/blog/0115/fig/fig.1.2.png" alt="Right Image" width="45%" style="margin-left: 10px;" />
</p>

<ul>
  <li>배치 방식:
    <ul>
      <li><strong>PPP(Poisson Point Process)</strong>: BS들이 독립적으로 배치되며, 현실적인 네트워크 배치를 모델링 가능</li>
      <li><strong>MHCPP(Matern Hard-Core Point Process)</strong>: PPP 기반 배치에서 BS 간 간섭을 줄이기 위해 최소 거리 제약 추가</li>
    </ul>
  </li>
</ul>

<h3 id="232-트래픽-예측-모델">2.3.2 트래픽 예측 모델</h3>
<ul>
  <li>BLSTM(Bidirectional Long Short-Term Memory)
    <ul>
      <li>과거 트래픽 데이터를 기반으로 사용자별 미래 트래픽 수요를 예측</li>
      <li>양방향 정보 흐름으로 시간 의존성과 장기적인 패턴 학습 가능</li>
      <li>BLSTM은 높은 예측 정확도를 제공하며, 특히 피크 트래픽에서 RNN 및 ARIMA보다 우수</li>
    </ul>
  </li>
</ul>

<h3 id="233-sinr-모델">2.3.3 SINR 모델</h3>

<table>
  <thead>
    <tr>
      <th><strong>기호</strong></th>
      <th><strong>설명</strong></th>
      <th><strong>단위</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>\(S_{i,k}\)</td>
      <td>사용자 \(k\)가 기지국 \(i\)에서 수신한 SINR</td>
      <td>dB</td>
    </tr>
    <tr>
      <td>\(p_{\theta(i)}\)</td>
      <td>기지국 \(i\)의 송신 전력 (단일 안테나 기준)</td>
      <td>W</td>
    </tr>
    <tr>
      <td>\(f_{\theta(i)}\)</td>
      <td>기지국 \(i\)의 주파수</td>
      <td>Hz</td>
    </tr>
    <tr>
      <td>\(w_{\theta(i)}\)</td>
      <td>기지국 \(i\)의 대역폭</td>
      <td>Hz</td>
    </tr>
    <tr>
      <td>\(L_{i,k}\)</td>
      <td>사용자 \(k\)와 기지국 \(i\) 간의 경로 손실</td>
      <td>dB</td>
    </tr>
    <tr>
      <td>\(\rho_{i,k}\)</td>
      <td>사용자 \(k\)와 기지국 \(i\) 간의 소규모 페이딩 계수 (Rayleigh fading, 지수분포)</td>
      <td>-</td>
    </tr>
    <tr>
      <td>\(\eta_0\)</td>
      <td>잡음 스펙트럼 밀도 (Noise spectral density)</td>
      <td>W/Hz</td>
    </tr>
    <tr>
      <td>\(d_{i,k}\)</td>
      <td>사용자 \(k\)와 기지국 \(i\) 간의 거리</td>
      <td>m</td>
    </tr>
    <tr>
      <td>\(c\)</td>
      <td>빛의 속도 (\(3 \times 10^8\))</td>
      <td>m/s</td>
    </tr>
    <tr>
      <td>\(\beta\)</td>
      <td>경로 손실 지수 (Path loss exponent)</td>
      <td>-</td>
    </tr>
    <tr>
      <td>\(\gamma_0\)</td>
      <td>SINR 임계값</td>
      <td>dB</td>
    </tr>
    <tr>
      <td>\(\Psi_{M}\)</td>
      <td>거대 기지국(MaBS) 집합</td>
      <td>-</td>
    </tr>
    <tr>
      <td>\(\Psi_{S}\)</td>
      <td>소형 기지국(MiBS) 집합</td>
      <td>-</td>
    </tr>
    <tr>
      <td>\(\Psi_{K}\)</td>
      <td>사용자 집합</td>
      <td>-</td>
    </tr>
    <tr>
      <td>\(\theta(i)\)</td>
      <td>기지국 \(i\)의 유형 (MaBS: 1, MiBS: 2)</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

<h4 id="2331-기지국-유형-정의-thetai">2.3.3.1 기지국 유형 정의 (\(\theta(i)\))</h4>

<p>기지국 \(i\)의 유형을 나타내는 이진 값:</p>

\[\theta(i) =
\begin{cases} 
1, &amp; \text{if } i \in \Psi_{M}, \\
2, &amp; \text{if } i \in \Psi_{S}.
\end{cases}\]

<h4 id="2332-경로-손실-모델-l_ik">2.3.3.2 경로 손실 모델 (\(L_{i,k}\))</h4>

<p>사용자 \(k\)와 기지국 \(i\) 간의 경로 손실:</p>

\[L_{i,k} = 20 \log \left( \frac{4 \pi f_{\theta(i)}^c}{c} \right) 
+ 10 \beta \log(d_{i,k}),
\quad \forall k \in \Psi_{K}, \ i \in \Psi_{M} \cup \Psi_{S}.\]

<h4 id="2333-sinr-계산-s_i-k">2.3.3.3 SINR 계산 (\(S_{i, k}\))</h4>

<p>사용자 \(k\)가 기지국 \(i\)에서 수신한 SINR:</p>

\[S_{i,k} = \frac{p_{\theta(i)} \rho_{i,k} L_{i,k}^{-1}}
{\sum_{j \in \Psi_{M} \cup \Psi_{S} \setminus \{i\}} 
p_{\theta(j)} \rho_{j,k} L_{j,k}^{-1} 
+ \eta_0 w_{\theta(i)}},
\quad \forall k \in \Psi_{K}, \ i \in \Psi_{M} \cup \Psi_{S}.\]

<h3 id="234-bs-전력-소비-모델">2.3.4 BS 전력 소비 모델</h3>

<table>
  <thead>
    <tr>
      <th><strong>기호</strong></th>
      <th><strong>설명</strong></th>
      <th><strong>단위</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>\(\mu_i(t)\)</td>
      <td>시간 \(t\)에서 기지국 \(i\)의 부하 비율</td>
      <td>-</td>
    </tr>
    <tr>
      <td>\(\Psi_i^K(t)\)</td>
      <td>시간 \(t\)에 기지국 \(i\)에 연결된 사용자 집합</td>
      <td>-</td>
    </tr>
    <tr>
      <td>\(P_{\theta(i)}^\alpha\)</td>
      <td>기지국 활성 상태 전력 소비</td>
      <td>W</td>
    </tr>
    <tr>
      <td>\(\alpha_{\theta(i)}\)</td>
      <td>기지국 \(i\)의 송신 안테나 개수 (MaBS: \(\alpha_1\), MiBS: \(\alpha_2\))</td>
      <td>-</td>
    </tr>
    <tr>
      <td>\(p_{\theta(i)}^{c}\)</td>
      <td>기지국 \(i\)의 회로 전력 소비(절전 상태)</td>
      <td>W</td>
    </tr>
  </tbody>
</table>

<h4 id="2341-사용자-요구-대역폭-계산">2.3.4.1 사용자 요구 대역폭 계산</h4>

<p>사용자 \(k\)가 기지국 \(i\)에 연결되었을 때, 주어진 시간 \(t\)에서 SINR이 임계값 \(\gamma_{0}\) 이상이면, Shannon-Hartley 이론에 따라 요구 대역폭은 아래와 같이 계산</p>

\[b_{i,k}(t) = \frac{r_k(t)}{\log_2 \left( 1 + S_{i,k} \right)}, \forall S_{i,k} \geq \gamma_0\]

<h4 id="2342-기지국-부하-계산">2.3.4.2 기지국 부하 계산</h4>

<p>기지국 \(i\)에 연결된 사용자들의 요구 대역폭으로부터 부하 비율을 계산할 수 있음. 시간 \(t\)에서 기지국 \(i\)의 부하는 다음과 같이 정의됨</p>

\[\mu_i(t) = \sum_{k \in \Psi_K^i(t)}\frac{b_{i,k}(t)}{w_{\theta(i)}}\]

<h4 id="2343-기지국-전력-소비-모델">2.3.4.3 기지국 전력 소비 모델</h4>

<p>활성 상태에서의 기지국 \(i\)의 전력 소비는 <strong>송신 전력</strong>과 <strong>회로 전력</strong>으로 나뉨</p>

\[P_{\theta(i)}^{\alpha}(t) = \alpha_{\theta(i)}p_{\theta(i)}\mu_i(t) + p_{\theta(i)}^c\]

<h4 id="235-blstm-모델">2.3.5 BLSTM 모델</h4>

<p><img src="/assets/img/blog/0115/fig/BLSTM.png" alt="Fig 1" /></p>

<ul>
  <li>BLSTM(Bidirectional Long Short-Term Memory)
    <ul>
      <li>시계열 데이터를 양방향으로 학습하는 RNN(Recurrent Neural Network)의 한 종류</li>
      <li>과거와 미래 정보를 모두 활용하여 더 정확한 예측 수행</li>
      <li>LSTM의 구조를 확장하여 Long-term dependencies와 패턴을 효과적으로 학습함</li>
    </ul>
  </li>
  <li>사용 목적
    <ul>
      <li>네트워크 트래픽의 시간적 변화 패턴을 예측</li>
      <li>각 사용자별 미래 트래픽을 정확히 예측하여 기지국 절전 저략에 활용</li>
    </ul>
  </li>
</ul>

<p>BLSTM 모델은 두 개의 LSTM 네트워크(Forward와 Backward)로 구성됨</p>

<ul>
  <li>Forward LSTM: 입력 데이터를 시간 순서대로 처리하여 패턴을 학습</li>
  <li>Backward LSTM: 입력 데이터를 시간 역순으로 처리하여 추가적인 정보를 학습</li>
  <li>두 결과를 병합하여 최종 출력값을 생성</li>
</ul>

<h3 id="24-문제-정의">2.4 문제 정의</h3>

<ul>
  <li><strong>목표</strong>: MiBS를 선택적으로 절전 상태로 전환해 네트워크 에너지 소비를 최소화</li>
  <li><strong>제약조건</strong>:
    <ul>
      <li>모든 사용자의 SINR이 임계값 이상이어야 함</li>
      <li>각 사용자의 트래픽 요구량을 충족해야 함</li>
      <li>기지국은 과부하 상태가 되어서는 안됨</li>
    </ul>
  </li>
  <li><strong>최적화 문제</strong>: 에너지 소비를 최소화하는 MiBS 절전 전략 설계</li>
</ul>

<h4 id="241-변수-정의">2.4.1 변수 정의</h4>

<ul>
  <li>
    <dl>
      <dt>Action Vector(\(a_t^{\phi}(t)\))</dt>
      <dd>기지국의 활성 상태를 나타내는 벡터</dd>
    </dl>

    <ul>
      <li>\(a_{\phi}^{i}(t) = 1\): 시간 \(t\)에 기지국 \(i\)가 활성 상태</li>
      <li>\(a_{\phi}^{i}(t) = 0\): 시간 \(t\)에 기지국 \(i\)가 절전 상태</li>
    </ul>
  </li>
  <li>활성 및 절전 기지국 집합
    <ul>
      <li>\(\mathcal{L}^{active}(t) = \{i \vert a_i^{\phi}(t = 1)\}\): 시간 \(t\)에 활성 상태인 기지국 집합</li>
      <li>\(\mathcal{L}^{active}(t) = \{i \vert a_i^{\phi}(t = 0)\}\): 시간 \(t\)에 절전 상태인 기지국 집합</li>
    </ul>
  </li>
  <li>최대 트래픽 요구량(\(R_k\))</li>
</ul>

\[R_k = \max_{t \in [T_1, T_2]} r_k(t), \quad \forall k \in \Psi_K.\]

<h4 id="242-최적화-목표">2.4.2 최적화 목표</h4>

<ul>
  <li>\([T_1, T_2]\) 동안 두 계층 HeCN의 전체 에너지 소비를 최소화하는 것이 최적화 문제의 목표</li>
  <li>총 전력 소비: 시간 \(t\)에 모든 기지국의 총 전력 소비는 다음과 같이 정의됨</li>
</ul>

\[\min_{\phi} \int_{T_1}^{T_2}
\sum_{i \in \Psi_M \cup \Psi_S}
\left( a_i^\phi(t) P^\alpha_{\theta(i)}(t)
+	\left( 1 - a_i^\phi(t) \right) P_{\theta(i)}^s \right) dt,\]

<h3 id="25-proposed-milsf-strategy">2.5 Proposed MiLSF Strategy</h3>

<p>Minimum Load Sleep First Algorithm(MiLSF)는 부하가 적은 MiBS부터 절전 상태로 전환하여 네트워크의 에너지 소비를 줄이는 전략임</p>

<h4 id="251-알고리즘-목표">2.5.1 알고리즘 목표</h4>

<ul>
  <li>네트워크 에너지 소비를 줄이기 위해 부하가 낮은 MiBS를 절전 상태로 전환</li>
  <li>사용자의 QoS를 유지하면서 기지국 부하를 재분배</li>
</ul>

<h4 id="252-알고리즘-절차">2.5.2 알고리즘 절차</h4>

<p><img src="/assets/img/blog/0115/fig/MiLSF.png" alt="Fig 5" /></p>

<h5 id="step-1-초기화">Step 1. 초기화</h5>

<ol>
  <li>활성 상태의 모든 MiBS 집합을 정의</li>
</ol>

\[\mathcal{I}_{\text{active}}(t) = { i \mid a_i^\phi(t) = 1, i \in \Psi_S }\]

<ol>
  <li>절전 상태 기지국 집합 초기화</li>
</ol>

\[\mathcal{I}_{\text{sleep}}(t) = \emptyset\]

<h4 id="step-2-mibs-부하-정렬">Step 2. MiBS 부하 정렬</h4>

<p>활성 상태 MiBS의 부하를 기준으로 오름차순 정렬</p>

\[i_1, i_2, \ldots, i_N \in \mathcal{I}{\text{active}}(t), \quad \text{where } \mu{i_1}(t) \leq \mu_{i_2}(t) \leq \cdots \leq \mu_{i_N}(t)\]

<h4 id="step-3-절전-가능-여부-평가">Step 3. 절전 가능 여부 평가</h4>

<p>부하가 가장 낮은 MiBS부터 절전 가능 여부를 평가</p>

<h5 id="1-mibs-i의-사용자를-인접한-활성-기지국으로-재배치">1. MiBS \(i\)의 사용자를 인접한 활성 기지국으로 재배치</h5>

\[\mu_j(t) = \mu_j(t) + \sum_{k \in \Psi_i^K(t)} \frac{b_{j,k}(t)}{w_{\theta(j)}},
\quad j \in \mathcal{I}_{\text{active}}(t) \setminus {i}.\]

<h5 id="2-제약-조건-확인">2. 제약 조건 확인</h5>

<ul>
  <li>모든 사용자의 SINR: \(S_{j,k} \geq \gamma_0, \quad \forall k \in \Psi_i^K(t), \quad \forall j \in \mathcal{I}_{\text{active}}(t)\)</li>
  <li>기지국 부하: \(\mu_j(t) \leq 1, \quad \forall j \in \mathcal{I}_{\text{active}}(t)\)</li>
</ul>

<h5 id="3-조건이-만족되면-mibs-i를-절전-상태로-전환">3. 조건이 만족되면 MiBS \(i\)를 절전 상태로 전환</h5>

\[a_i^\phi(t) = 0, \quad \mathcal{I}{\text{sleep}}(t) = \mathcal{I}{\text{sleep}}(t) \cup {i}\]

<h5 id="4-조건이-만족되지-않으면-mibs-i는-활성-상태-유지">4. 조건이 만족되지 않으면 MiBS \(i\)는 활성 상태 유지</h5>

<h4 id="step-4-반복">Step 4: 반복</h4>

<p>절전 가능 여부를 평가한 MiBS를 제외한 나머지 기지국으로 돌아가 Step 3을 반복, 모든 MiBS를 평가할 때까지 반복함</p>

<h4 id="253-알고리즘-종료-조건">2.5.3 알고리즘 종료 조건</h4>
<ul>
  <li>모든 MiBS를 평가한 후 더 이상 절전 상태로 전환할 수 없는 경우 알고리즘 종료</li>
  <li>절전 상태 기지국 집합 \(\mathcal{J}_{sleep}(t)\)과 활성 상태 기지국 집합 \(\mathcal{J}_{active}(t)\) 반환</li>
</ul>

<h2 id="numerical-results">Numerical Results</h2>

<h3 id="실험-목표">실험 목표</h3>

<ul>
  <li>BLSTM 기반 트래픽 예측 모델과 MiLSF 알고리즘의 성능 평가</li>
  <li>기존 절전 전략과의 비교를 통해 MiLSF의 에너지 효율성 및 QoS 유지 능력을 검증</li>
</ul>

<h3 id="blstm-트래픽-예측-성능">BLSTM 트래픽 예측 성능</h3>

<h5 id="실험-설정">실험 설정</h5>
<ul>
  <li>다양한 트래픽 패턴에서 BLSTM의 예측 성능 평가</li>
  <li>비교 모델: RNN, ARIMA</li>
</ul>

<p><img src="/assets/img/blog/0115/fig/fig.7.png" alt="Fig 7" />
<img src="/assets/img/blog/0115/fig/fig.8.png" alt="Fig 8" />
<img src="/assets/img/blog/0115/fig/fig.9.png" alt="Fig 9" /></p>

<h5 id="결과-요약">결과 요약</h5>

<p><img src="/assets/img/blog/0115/fig/MAE.png" alt="Fig 6" /></p>

<p>예측 정확도:</p>
<ul>
  <li>BLSTM은 RNN 및 ARIMA 보다 Mean Absolute Error(MAE)와 Root Mean Square Error(RMSE)에서 더 낮은 값을 기록</li>
  <li>특히 트래픽 피크 시간에서 예측 성능이 우수</li>
</ul>

<p>시계열 데이터의 학습:</p>
<ul>
  <li>BLSTM은 양방향 학습을 통해 장기적이고 복잡한 트래픽 변화를 더 잘 포착
을</li>
</ul>

<h3 id="milsf-알고리즘-성능">MiLSF 알고리즘 성능</h3>

<h5 id="실험-설정-1">실험 설정</h5>

<p><img src="/assets/img/blog/0115/fig/table.1.png" alt="Table 1" /></p>

<ul>
  <li>다양한 네트워크 부하와 배치 조건에서 MiLSF와 기존 절전 전략의 비교. 추가적으로 low-load 기간(10:00 p.m. - 6:00 a.m.)에는 user들의 움직임이 없는 것으로 고려하였음.</li>
</ul>

<p>\(\rightarrow\) 결정한 MiBS들을 10:00 p.m. - 6:00 a.m.에 sleep 모드로 전환
\(\rightarrow\) 이 시간대 sleep 할 최적의 MiBS들을 고르는 것이 중요</p>

<ul>
  <li>비교 전략
    <ul>
      <li>Randomly Sleep(RS): 임의로 기지국을 절전 모드로 전환</li>
      <li>CUR(Closest User Reallocation): 사용자 재배치를 통해 가까운 기지국 연결</li>
      <li>CBSSF(Closest Base Station Sleep First): 가장 가까운 기지국부터 절전</li>
    </ul>
  </li>
</ul>

<h4 id="결과-요약-1">결과 요약</h4>

<ul>
  <li>에너지 절감
    <ul>
      <li>MiLSF가 RS, CUR, CBSSF보다 에너지 소비를 크게 줄임</li>
      <li>특히 네트워크 부하가 낮은 시나리오에서 에너지 절감률이 가장 높음</li>
    </ul>
  </li>
  <li>기지국 배치의 영향
    <ul>
      <li>PPP 배치: MiLSF가 효율적으로 작동하며, 부하 분산 효과를 극대화</li>
      <li>MHCPP 배치: 간섭이 줄어들며, MiLSF의 에너지 절감률이 더욱 향상</li>
    </ul>
  </li>
  <li>사용자 수의 영향
    <ul>
      <li>사용자 수가 증가할수록 MiLSF는 에너지 절감률을 유지하면서 QoS를 만족</li>
      <li>기존 전략은 사용자 증가 시 QoS가 약화되는 경향을 보임</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/blog/0115/fig/fig.10.png" alt="Fig 10" /></p>

<ul>
  <li>SINR 임계값 변화
    <ul>
      <li>높은 SINR 임계값에서도 MiLSF는 QoS를 유지하며, 에너지 절감 효과를 제공</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/blog/0115/fig/fig.10.png" alt="Fig 10" /></p>

<ul>
  <li>절전 기지국 개수 변화
    <ul>
      <li>네트워크 부하가 낮을수록 더 많은 MiBS를 절전 상태로 전환 가능</li>
      <li>MiLSF는 절전 가능한 MiBS의 개수를 최대화하면서 QoS를 유지</li>
      <li>네트워크 부하가 증가하면 MiBS를 활성 상태로 유지해야 하므로 절전 기지국 개수 감소</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/img/blog/0115/fig/fig.11.png" alt="Fig 11" /></p>

<h2 id="future-work">Future Work</h2>

<ul>
  <li>빔포밍, 전력 제어와 같은 간섭 완화 기법 통합</li>
  <li>동적으로 변화하는 네트워크 환경에서의 적용</li>
  <li>트래픽 예측의 개선</li>
</ul>

<hr />

<h1 id="3-take-away">3. Take Away</h1>

<ul>
  <li>시뮬레이션 파라미터들을 참고하여 NS-3에서 사용</li>
  <li>10 p.m. - 6 a.m. 까지 사용자를 고정시킨 후 cell on/off를 실행</li>
  <li>예측 알고리즘과 on/off 알고리즘의 결합</li>
</ul>]]></content><author><name>&lt;firstname&gt; &lt;lastname&gt;</name><email>&lt;mail@domain.tld&gt;</email></author><category term="paper" /><summary type="html"><![CDATA[**Date**: 2014.06.17 **Tag**: [Heterogeneous cellular networks], [Traffic forecasting], [Energy saving], [SINR], [Quality of service], [BLSTM]]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/blog/0115/thumbnail/thumbnail.png" /><media:content medium="image" url="http://localhost:4000/assets/img/blog/0115/thumbnail/thumbnail.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">The Prediction Analysis of Cellular Radio Access Network Traffic - From Entropy Theory to Networking Practice</title><link href="http://localhost:4000/blog/paper/2025-01-14-the-prediction-analysis-of-cellular-radio-access-network-traffic-from-entropy-theory-to-networking-practice/" rel="alternate" type="text/html" title="The Prediction Analysis of Cellular Radio Access Network Traffic - From Entropy Theory to Networking Practice" /><published>2025-01-14T00:00:00+09:00</published><updated>2025-01-14T00:00:00+09:00</updated><id>http://localhost:4000/blog/paper/the-prediction-analysis-of-cellular-radio-access-network-traffic-from-entropy-theory-to-networking-practice</id><content type="html" xml:base="http://localhost:4000/blog/paper/2025-01-14-the-prediction-analysis-of-cellular-radio-access-network-traffic-from-entropy-theory-to-networking-practice/"><![CDATA[<!--more-->
<ul class="large-only" id="markdown-toc">
  <li><a href="#논문-개요-분석" id="markdown-toc-논문-개요-분석">논문 개요 분석</a>    <ul>
      <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li>
      <li><a href="#traffic-prediction-theoretical-analysis-and-practical-performance" id="markdown-toc-traffic-prediction-theoretical-analysis-and-practical-performance">Traffic Prediction: Theoretical ANalysis and Practical Performance</a>        <ul>
          <li><a href="#prediction-dataset-description-and-analysis-methodology" id="markdown-toc-prediction-dataset-description-and-analysis-methodology">Prediction Dataset Description and Analysis Methodology</a></li>
          <li><a href="#prediction-analysis-to-what-extent-is-the-prior-information-required" id="markdown-toc-prediction-analysis-to-what-extent-is-the-prior-information-required">Prediction Analysis: To What Extent Is the Prior Information Required?</a></li>
          <li><a href="#prediction-performance-the-current-state-of-research" id="markdown-toc-prediction-performance-the-current-state-of-research">Prediction Performance: The Current State of Research</a></li>
        </ul>
      </li>
      <li><a href="#traffic-prediction-and-future-network-architecture-directions-and-applications" id="markdown-toc-traffic-prediction-and-future-network-architecture-directions-and-applications">Traffic Prediction and Future Network Architecture: Directions and Applications</a>        <ul>
          <li><a href="#brief-description-of-the-traffic-based-sdran-architecture" id="markdown-toc-brief-description-of-the-traffic-based-sdran-architecture">Brief Description of the Traffic-Based SDRAN Architecture</a></li>
          <li><a href="#large-scale-traffic-aware-resource-management" id="markdown-toc-large-scale-traffic-aware-resource-management">Large-Scale Traffic-Aware Resource Management</a></li>
          <li><a href="#small-scale-flow-centric-resource-allocation" id="markdown-toc-small-scale-flow-centric-resource-allocation">Small-Scale Flow-Centric Resource Allocation</a></li>
        </ul>
      </li>
      <li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></li>
    </ul>
  </li>
  <li><a href="#1-why-this-paper" id="markdown-toc-1-why-this-paper">1. Why this paper</a>    <ul>
      <li><a href="#11-what-is-the-research-topic-and-why-was-it-chosen" id="markdown-toc-11-what-is-the-research-topic-and-why-was-it-chosen">1.1 What is the research topic and why was it chosen?</a></li>
      <li><a href="#12-what-are-the-objectives-of-the-study" id="markdown-toc-12-what-are-the-objectives-of-the-study">1.2 What are the objectives of the study?</a></li>
      <li><a href="#13-what-methods-were-used-to-conduct-the-research" id="markdown-toc-13-what-methods-were-used-to-conduct-the-research">1.3 What methods were used to conduct the research?</a></li>
      <li><a href="#14-what-results-were-obtained" id="markdown-toc-14-what-results-were-obtained">1.4 What results were obtained?</a></li>
      <li><a href="#15-what-is-the-significance-of-the-results" id="markdown-toc-15-what-is-the-significance-of-the-results">1.5 What is the significance of the results?</a></li>
    </ul>
  </li>
  <li><a href="#2-paper-summarization" id="markdown-toc-2-paper-summarization">2. Paper Summarization</a>    <ul>
      <li><a href="#21-데이터셋-및-분석-방법론" id="markdown-toc-21-데이터셋-및-분석-방법론">2.1 데이터셋 및 분석 방법론</a>        <ul>
          <li><a href="#조건부-엔트로피conditional-entropy" id="markdown-toc-조건부-엔트로피conditional-entropy">조건부 엔트로피(Conditional Entropy)</a></li>
        </ul>
      </li>
      <li><a href="#22-예측-분석" id="markdown-toc-22-예측-분석">2.2 예측 분석</a>        <ul>
          <li><a href="#221-시간적-연관성-temporal-correlation" id="markdown-toc-221-시간적-연관성-temporal-correlation">2.2.1 시간적 연관성 (Temporal Correlation)</a></li>
          <li><a href="#222-공간적-연관성-spatial-correlation" id="markdown-toc-222-공간적-연관성-spatial-correlation">2.2.2 공간적 연관성 (Spatial Correlation)</a></li>
          <li><a href="#223-서비스-간-연관성-inter-service-correlation" id="markdown-toc-223-서비스-간-연관성-inter-service-correlation">2.2.3 서비스 간 연관성 (Inter-Service Correlation)</a></li>
        </ul>
      </li>
      <li><a href="#23-traffic-prediction-and-future-network-architecture" id="markdown-toc-23-traffic-prediction-and-future-network-architecture">2.3 Traffic Prediction and Future Network Architecture</a>        <ul>
          <li><a href="#231-traffic-based-sdran-architecture" id="markdown-toc-231-traffic-based-sdran-architecture">2.3.1 Traffic-Based SDRAN Architecture</a></li>
          <li><a href="#232-large-scale-traffic-aware-resource-management" id="markdown-toc-232-large-scale-traffic-aware-resource-management">2.3.2 Large-Scale Traffic-Aware Resource Management</a></li>
          <li><a href="#233-small-scale-flow-centric-resource-allocation" id="markdown-toc-233-small-scale-flow-centric-resource-allocation">2.3.3 Small-Scale Flow-Centric Resource Allocation</a></li>
        </ul>
      </li>
      <li><a href="#24-conclusion" id="markdown-toc-24-conclusion">2.4 Conclusion</a></li>
    </ul>
  </li>
  <li><a href="#3-take-away" id="markdown-toc-3-take-away">3. Take Away</a></li>
</ul>

<h1 id="논문-개요-분석">논문 개요 분석</h1>

<h2 id="introduction">Introduction</h2>

<ul>
  <li>본 논문의 연구 배경과 연구 필요성 언급</li>
  <li>기존 연구의 한계점 지적 및 본 논문의 목표와 연구 범위 제시</li>
</ul>

<h2 id="traffic-prediction-theoretical-analysis-and-practical-performance">Traffic Prediction: Theoretical ANalysis and Practical Performance</h2>

<h3 id="prediction-dataset-description-and-analysis-methodology">Prediction Dataset Description and Analysis Methodology</h3>
<ul>
  <li>데이터 수집 과정 및 분석 방법론</li>
  <li>데이터 전처리 및 트래픽 엔트로피 계산</li>
</ul>

<h3 id="prediction-analysis-to-what-extent-is-the-prior-information-required">Prediction Analysis: To What Extent Is the Prior Information Required?</h3>
<ul>
  <li>트래픽 예측에 필요한 사전 정보의 범위를 논의</li>
  <li>시간적, 공간적, 서비스 간 상호작용을 통한 예측 가능성 분석</li>
</ul>

<h3 id="prediction-performance-the-current-state-of-research">Prediction Performance: The Current State of Research</h3>
<ul>
  <li>트래픽 예측 성능을 평가하고, 현재 연구 방법론의 한계를 제시</li>
</ul>

<h2 id="traffic-prediction-and-future-network-architecture-directions-and-applications">Traffic Prediction and Future Network Architecture: Directions and Applications</h2>

<h3 id="brief-description-of-the-traffic-based-sdran-architecture">Brief Description of the Traffic-Based SDRAN Architecture</h3>
<ul>
  <li>SDRAN 구조 소개</li>
</ul>

<h3 id="large-scale-traffic-aware-resource-management">Large-Scale Traffic-Aware Resource Management</h3>
<ul>
  <li>대규모 트래픽 예측 기반 자원 관리 기법 논의</li>
</ul>

<h3 id="small-scale-flow-centric-resource-allocation">Small-Scale Flow-Centric Resource Allocation</h3>
<ul>
  <li>세부 흐름 중심의 자원 할당 방안을 설명</li>
</ul>

<h2 id="conclusion">Conclusion</h2>
<ul>
  <li>논문의 주요 결론과 향후 연구 방향 제시</li>
</ul>

<hr />

<h1 id="1-why-this-paper">1. Why this paper</h1>

<ol>
  <li>SKT 트래픽 예측 논문 레퍼런스 조사</li>
  <li>트래픽 시/공간 관계 조사</li>
</ol>

<h2 id="11-what-is-the-research-topic-and-why-was-it-chosen">1.1 What is the research topic and why was it chosen?</h2>

<ul>
  <li><strong>연구 주제</strong>: 셀룰러 RAN 트래픽 예측 가능성을 이론적으로 분석하고, 두를 활용한 네트워크 설계 방법 제안</li>
  <li><strong>선택 이유</strong>:
    <ul>
      <li>셀룰러 RAN 트래픽이 기존 음성 중심에서 데이터 중심으로 변화했기 때문</li>
      <li>셀룰러 RAN은 자원 제한, 사용자 이동성으로 인해 기존 연구를 그대로 적용하기 어려움</li>
      <li>에너지 효율적인 네트워크 설계와 효과적인 자원 관리를 위해 트래픽 예측의 필요성 대두</li>
    </ul>
  </li>
</ul>

<h2 id="12-what-are-the-objectives-of-the-study">1.2 What are the objectives of the study?</h2>

<ul>
  <li>엔트로피 이론을 활용해 셀룰러 RAN 트래픽의 시간적, 공간적, 서비스 간 예측 가능성을 분석</li>
  <li>예측 결과를 바탕으로 에너지 효율적이고 트래픽 기반의 SD-RAN 설계</li>
  <li>트래픽 예측을 통해 네트워크 자원을 효율적으로 관리하고 사용자 경험을 개선</li>
</ul>

<h2 id="13-what-methods-were-used-to-conduct-the-research">1.3 What methods were used to conduct the research?</h2>
<ul>
  <li>데이터셋: 차이나 모바일에서 7000개 기지국의 1개월간 트래픽 데이터 수집</li>
  <li>분석 방법: 엔트로피 이론을 기반으로 데이터의 시간적, 공간적 특성을 정량화하여 불확실성을 분석</li>
  <li>추가적 접근: 서비스 간 연관성과 시간, 공간적 정보의 조합이 트래픽 예측에 미치는 영향을 평가</li>
</ul>

<h2 id="14-what-results-were-obtained">1.4 What results were obtained?</h2>

<ul>
  <li>엔트로피 분석 결과
    <ul>
      <li>시간적 정보는 예측에 가장 큰 영향을 미치며, 과거 데이터가 많을수록 정확도가 향상</li>
      <li>공간적 정보는 추가적인 예측 개선을 지원하지만, 시간적 정보보다 덜 중요함</li>
      <li>음성 및 문자 서비스 간 상관관계는 높으나, 데이터 서비스는 상대적으로 독립적임</li>
    </ul>
  </li>
  <li>트래픽 기반 SD-RAN 설계
    <ul>
      <li>제어 평면과 데이터 평면의 분리를 통해 네트워크 자원 관리의 유연성을 제공</li>
      <li>대규모 자원 관리와 소규모 플로우 중심 자원 할당 가능</li>
    </ul>
  </li>
</ul>

<h2 id="15-what-is-the-significance-of-the-results">1.5 What is the significance of the results?</h2>
<ul>
  <li>셀룰러 RAN 트래픽은 시간적, 공간적, 서비스 간 연관성을 활용해 효과적으로 예측할 수 있음을 증명</li>
  <li>트래픽 기반 예측은 에너지 효율적인 네트워크 설계 및 운영에 핵심 역할을 수행</li>
  <li>SD-RAN은 미래 네트워크 아키텍쳐의 중요한 방향성으로, 효율적인 자원 배분과 사용자 경험 향상을 가능하게 함</li>
</ul>

<hr />

<h1 id="2-paper-summarization">2. Paper Summarization</h1>

<p>논문의 목표는 다음과 같음</p>

<ol>
  <li>엔트로피 이론을 활용하여 셀룰러 RAN 트래픽의 시간적, 공간적, 서비스 간 연관성을 분석</li>
  <li>예측 결과를 기반으로 효율적인 SD-RAN 설계를 제안</li>
</ol>

<h2 id="21-데이터셋-및-분석-방법론">2.1 데이터셋 및 분석 방법론</h2>
<ul>
  <li><strong>데이터셋</strong>: 약 7000개의 기지국에서 수집한 1개월 분량의 트래픽 데이터 사용(음성, 문자, 데이터 서비스 포함)</li>
  <li><strong>전처리</strong>: 데이터를 시간 간격으로 정량화하여 각 셀에서 트래픽 변화 분석</li>
</ul>

<p>엔트로피는 Shannon이 불확실성을 측정하기 위해 정의한 값으로, 트래픽의 예측 가능성을 분석하는 데 사용됨</p>

<p>엔트로피의 정의는 다음과 같음</p>

\[H(X) = -\sum_{i=1}^{n} p(x_i) \log_2 p(x_i) \tag{1}\]

<ul>
  <li>\(p(x_i)\): 특정 트래픽 수준 \(x_i\)가 발생할 확률</li>
</ul>

<div align="center">
  <img src="/assets/img/blog/0114/fig/fig_1.png" alt="Fig. 1" />
</div>

<p>Fig 1은 두 개의 셀에서 음성, 문자, 데이터 트래픽의 엔트로피 값을 보여줌</p>
<ul>
  <li><strong>음성 트래픽</strong>: 가장 큰 변동성을 보이며, 엔트로피 값이 높음</li>
  <li><strong>데이터 트래픽</strong>: 가장 안정적이며, 엔트로피 값이 낮음</li>
  <li>서비스 유형에 따라 트래픽 특성이 달라짐을 나타냄</li>
</ul>

<div align="center">
  <img src="/assets/img/blog/0114/fig/table_1.png" alt="Table. 1" />
</div>

<h4 id="조건부-엔트로피conditional-entropy">조건부 엔트로피(Conditional Entropy)</h4>

<p>트래픽 예측은 과거 데이터를 기반으로 미래 트래픽의 불확실성을 줄이는 것을 목표로 함. 이를 위해 <strong>조건부 엔트로피</strong>를 계산</p>

\[\begin{align}
H(X|Y) &amp;= \sum_{i,j} p(x_i, y_j) \log \frac{p(y_j)}{p(x_i, y_j)} \notag \\
       &amp;= H(X, Y) - H(Y) \tag{2}
\end{align}\]

<p align="center">
  <img src="/assets/img/blog/0114/fig/fig_3.png" alt="Left Image" width="45%" style="margin-right: 10px;" />
  <img src="/assets/img/blog/0114/fig/fig_2.png" alt="Right Image" width="45%" style="margin-left: 10px;" />
</p>

<h2 id="22-예측-분석">2.2 예측 분석</h2>

<h3 id="221-시간적-연관성-temporal-correlation">2.2.1 시간적 연관성 (Temporal Correlation)</h3>

<p>과거 트래픽 데이터는 현재 및 미래 트래픽 예측에 중요한 역할을 함</p>
<ul>
  <li>Random 엔트로피(사전 정보 X): \(H(X)\) = 2.1492 bits(음성 트래픽)</li>
  <li>2시간 전 데이터를 추가로 사용했을 때: Conditional 엔트로피 \(H(X \vert T)\) = 0.5880 bits로 감소</li>
  <li>이는 불확실성이 약 73% 감소했음을 의미하며, 더 긴 기간의 데이터를 사용할수록 불확실성은 더욱 감소</li>
</ul>

<h3 id="222-공간적-연관성-spatial-correlation">2.2.2 공간적 연관성 (Spatial Correlation)</h3>

<p>인접한 셀에서의 트래픽 데이터는 예측 정확도를 개선할 수 있음</p>
<ul>
  <li>3개의 인접 셀 정보를 사용할 경우 \(H(X \vert S)\) = 0.9043</li>
  <li>공간적 정보는 시간적 정보보다 덜 중요한 역할을 함</li>
</ul>

<h3 id="223-서비스-간-연관성-inter-service-correlation">2.2.3 서비스 간 연관성 (Inter-Service Correlation)</h3>

<p>다른 서비스 유형 간의 연관성을 활용</p>
<ul>
  <li>문자 트래픽은 음성 트래픽 예측에 유용하며, 조건부 엔트로피 \(H(X \vert Text)\) = 1.3966</li>
  <li>데이터 트래픽은 독립적인 특성이 강해 다른 서비스의 정보를 활용하기 어려움</li>
</ul>

<h2 id="23-traffic-prediction-and-future-network-architecture">2.3 Traffic Prediction and Future Network Architecture</h2>

<h3 id="231-traffic-based-sdran-architecture">2.3.1 Traffic-Based SDRAN Architecture</h3>

<div align="center">
  <img src="/assets/img/blog/0114/fig/fig_4.png" alt="Fig. 4" />
</div>

<ul>
  <li>제어 평면과 데이터 평면을 분리하여 네트워크 관리를 유연화</li>
  <li>구성 요소
    <ul>
      <li>트래픽 예측 엔진: 실시간 트래픽 변화 감지</li>
      <li>정책 엔진: 자원 할당 및 네트워크 상태 조정</li>
      <li>API: 외부 어플리케이션과 상호작용</li>
    </ul>
  </li>
</ul>

<h3 id="232-large-scale-traffic-aware-resource-management">2.3.2 Large-Scale Traffic-Aware Resource Management</h3>

<div align="center">
  <img src="/assets/img/blog/0113/fig/fig_5.png" alt="Fig 5" />
</div>

<ul>
  <li>과거 데이터(20-34시간)를 더 많이 사용할수록 RMSE 감소</li>
  <li>음성 트래픽의 RMSE가 데이터 트래픽보다 더 급격히 감소하여 더 쉽게 예측 가능</li>
</ul>

<h3 id="233-small-scale-flow-centric-resource-allocation">2.3.3 Small-Scale Flow-Centric Resource Allocation</h3>

<ul>
  <li>애플리케잉션 요구 사항에 맞춰 트래픽을 세분화하여 자원 배정
    <ul>
      <li>HTTP 브라우징: WiFi 오프로딩 가능</li>
      <li>실시간 스트리밍: 대역폭 우선 할당</li>
    </ul>
  </li>
</ul>

<h2 id="24-conclusion">2.4 Conclusion</h2>

<ul>
  <li>시간적 연관성이 예측 정확도에 가장 중요한 요소</li>
  <li>공간적 연관성과 서비스 간 연관성도 보조적인 기여를 함</li>
  <li>SDRAN은 에너지 절약 및 효율적 네트워크 자원 관리를 위한 중요한 방향성 제시</li>
</ul>

<hr />

<h1 id="3-take-away">3. Take Away</h1>
<ul>
  <li>엔트로피를 이용한 트래픽 시공간 사전 분석</li>
  <li>ML을 돌릴 때 Training 시간을 조절하면서 결과 비교 그래프 첨부</li>
  <li>데이터 각 열들간의 상관성을 바탕으로 조건부 엔트로피 계산</li>
</ul>]]></content><author><name>&lt;firstname&gt; &lt;lastname&gt;</name><email>&lt;mail@domain.tld&gt;</email></author><category term="paper" /><summary type="html"><![CDATA[**Date**: 2014.06.14 **Tag**: [Cellular networks], [Predictive models], [Telecommunication traffic], [Computer architecture], [Uncertainty], [Entropy], [Signal processing]]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/blog/0114/thumbnail/thumbnail.png" /><media:content medium="image" url="http://localhost:4000/assets/img/blog/0114/thumbnail/thumbnail.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Analyzing and Modeling Spatio-Temporal Dependence of Cellular Traffic at City Scale</title><link href="http://localhost:4000/blog/paper/2025-01-13-analyzing-and-modeling-spatil-temporal-dependence-of-cellular-traffic-at-city-scale/" rel="alternate" type="text/html" title="Analyzing and Modeling Spatio-Temporal Dependence of Cellular Traffic at City Scale" /><published>2025-01-13T00:00:00+09:00</published><updated>2025-01-13T00:00:00+09:00</updated><id>http://localhost:4000/blog/paper/analyzing-and-modeling-spatil-temporal-dependence-of-cellular-traffic-at-city-scale</id><content type="html" xml:base="http://localhost:4000/blog/paper/2025-01-13-analyzing-and-modeling-spatil-temporal-dependence-of-cellular-traffic-at-city-scale/"><![CDATA[<!--more-->
<ul class="large-only" id="markdown-toc">
  <li><a href="#1-why-this-paper" id="markdown-toc-1-why-this-paper">1. Why this paper</a></li>
  <li><a href="#2-paper-summarization" id="markdown-toc-2-paper-summarization">2. Paper Summarization</a>    <ul>
      <li><a href="#21-연구-주제는" id="markdown-toc-21-연구-주제는">2.1 연구 주제는?</a>        <ul>
          <li><a href="#211-연구-주제" id="markdown-toc-211-연구-주제">2.1.1 연구 주제</a></li>
          <li><a href="#212-contribution" id="markdown-toc-212-contribution">2.1.2 Contribution</a></li>
          <li><a href="#213-주제-선택-이유" id="markdown-toc-213-주제-선택-이유">2.1.3 주제 선택 이유</a></li>
        </ul>
      </li>
      <li><a href="#22-연구의-목표는" id="markdown-toc-22-연구의-목표는">2.2 연구의 목표는?</a></li>
      <li><a href="#23-연구-수행-방법은" id="markdown-toc-23-연구-수행-방법은">2.3 연구 수행 방법은?</a>        <ul>
          <li><a href="#231-셀룰러-네트워크-구조" id="markdown-toc-231-셀룰러-네트워크-구조">2.3.1 셀룰러 네트워크 구조</a></li>
          <li><a href="#232-사용-데이터셋" id="markdown-toc-232-사용-데이터셋">2.3.2 사용 데이터셋</a>            <ul>
              <li><a href="#233a-spatio-temporal-foundation-of-cellular-traffic" id="markdown-toc-233a-spatio-temporal-foundation-of-cellular-traffic">2.3.3.A Spatio-Temporal Foundation of Cellular Traffic</a></li>
              <li><a href="#233b-modeling-spatio-temporal-dependence" id="markdown-toc-233b-modeling-spatio-temporal-dependence">2.3.3.B Modeling Spatio-Temporal Dependence</a></li>
            </ul>
          </li>
          <li><a href="#234-exploratory-dependence-analysis" id="markdown-toc-234-exploratory-dependence-analysis">2.3.4 Exploratory Dependence Analysis</a></li>
          <li><a href="#235-modeling-spatial-temporal-dependence" id="markdown-toc-235-modeling-spatial-temporal-dependence">2.3.5 Modeling Spatial-Temporal Dependence</a>            <ul>
              <li><a href="#235a-estimation-of-model-parameters" id="markdown-toc-235a-estimation-of-model-parameters">2.3.5.A Estimation of Model Parameters</a></li>
              <li><a href="#235b-evaluation-of-prediction-performance" id="markdown-toc-235b-evaluation-of-prediction-performance">2.3.5.B Evaluation of Prediction Performance</a>                <ul>
                  <li><a href="#예측-방식" id="markdown-toc-예측-방식">예측 방식</a></li>
                  <li><a href="#성능-평가-지표-rmse" id="markdown-toc-성능-평가-지표-rmse">성능 평가 지표: RMSE</a></li>
                </ul>
              </li>
              <li><a href="#235c-discussions" id="markdown-toc-235c-discussions">2.3.5.C Discussions</a>                <ul>
                  <li><a href="#separable-모델" id="markdown-toc-separable-모델">Separable 모델</a></li>
                  <li><a href="#non-separable-모델" id="markdown-toc-non-separable-모델">Non-Separable 모델</a></li>
                  <li><a href="#한계-극복-방안" id="markdown-toc-한계-극복-방안">한계 극복 방안</a></li>
                  <li><a href="#주요-시사점-및-결론" id="markdown-toc-주요-시사점-및-결론">주요 시사점 및 결론</a></li>
                </ul>
              </li>
            </ul>
          </li>
          <li><a href="#236-conclusion" id="markdown-toc-236-conclusion">2.3.6 Conclusion</a>            <ul>
              <li><a href="#연구-개요" id="markdown-toc-연구-개요">연구 개요</a></li>
              <li><a href="#주요-발견" id="markdown-toc-주요-발견">주요 발견</a></li>
              <li><a href="#future-work" id="markdown-toc-future-work">Future Work</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#3-take-away" id="markdown-toc-3-take-away">3. Take Away</a></li>
</ul>

<h1 id="1-why-this-paper">1. Why this paper</h1>

<ol>
  <li>SKT 트래픽 예측 논문 레퍼런스 조사</li>
  <li>트래픽 시/공간 관계 조사</li>
</ol>

<h1 id="2-paper-summarization">2. Paper Summarization</h1>

<h2 id="21-연구-주제는">2.1 연구 주제는?</h2>

<h3 id="211-연구-주제">2.1.1 연구 주제</h3>
<ul>
  <li>도시 규모의 셀룰러 네트워크에서 트래픽의 시공간 의존성을 분석하과 이를 모델링함으로써 트래픽 특성을 정량적으로 파악하는 것</li>
</ul>

<h3 id="212-contribution">2.1.2 Contribution</h3>
<ul>
  <li>최초로 실제 상용 데이터에서 셀룰러 트래픽의 시공간 의존성을 이해하기 위한 노력을 함</li>
  <li>트래픽 의존성에 대한 몇 가지 특성을 발견함</li>
</ul>

<h3 id="213-주제-선택-이유">2.1.3 주제 선택 이유</h3>
<ul>
  <li>셀룰러 네트워크는 사용자 이동성과 비선형 트래픽 분포 특성으로 인해 비균질성과 시간적 변동성을 보임. 기존 연구는 시간적 특성이나 공간적 특성 중 하나에만 집중하거나 두 특성을 독립적으로 다루는 경우가 많았음. 그러나 셀룰러 트래픽은 시간과 공간 간 상호작용을 반영해야 더 정확한 네트워크 모델링 및 자원 최적화가 가능함. 본 연구는 도시의 대규모 데이터를 통해 이러한 상호작용을 분석하고, 네트워크 설계와 관리에 필요한 인사이트를 제공하기 위해 주제를 선택</li>
</ul>

<h2 id="22-연구의-목표는">2.2 연구의 목표는?</h2>
<ol>
  <li>도시 규모의 셀룰러 트래픽 데이터를 분석하여 시공간 의존성을 파악</li>
  <li>공간적 비균질성과 시간적 의존성을 통합적으로 고려한 모델을 개발하여 트래픽 패턴을 정밀하게 설명하고 예측 성능을 향상</li>
  <li>개발된 모델을 통해 네트워크 자원 관리 및 최적화를 위한 실질적인 통찰 제공</li>
</ol>

<h2 id="23-연구-수행-방법은">2.3 연구 수행 방법은?</h2>

<h3 id="231-셀룰러-네트워크-구조">2.3.1 셀룰러 네트워크 구조</h3>

<div align="center">
  <img src="/assets/img/blog/0113/fig/fig_1.png" alt="Figure 1" />
</div>

<ul>
  <li>셀룰러 네트워크는 3개의 주요 부분으로 구성됨
    <ul>
      <li>RAN: 사용자 장치(UE)와 기지국(BTS) 간 통신 담당</li>
      <li>Core Network: 데이터 패킷 라우팅(BSC \(\rightarrow\) SGSN \(\rightarrow\) GGSN)을 통해 모바일 네트워크와 인터넷 연결</li>
      <li>Public Network: 외부 인터넷 연결 제공</li>
    </ul>
  </li>
  <li>데이터는 Network Traffic Mining Platform(NTMP)에서 DPI를 통해 HTTP 로그를 추출 후 분석됨</li>
</ul>

<h3 id="232-사용-데이터셋">2.3.2 사용 데이터셋</h3>
<ul>
  <li>데이터셋 정보
    <ul>
      <li>수집 기간: 2012.08.20 - 2021.08.26, 7일간의 트래픽 데이터</li>
      <li>수집 범위: 28 km x 35 km, 도시 중심 및 교외 포함</li>
      <li>수집량:
        <ul>
          <li>13,000개 기지국에서 생성된 트래픽</li>
          <li>452,000명의 사용자가 생성한 총 379백만 건의 HTTP 기록</li>
        </ul>
      </li>
      <li>데이터 특성:
        <ul>
          <li>각 사용자 활동은 기지국 좌표(위도, 경도)와 함께 기록됨</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="233a-spatio-temporal-foundation-of-cellular-traffic">2.3.3.A Spatio-Temporal Foundation of Cellular Traffic</h4>
<ul>
  <li>셀룰러 트래픽의 시공간 모델링
    <ul>
      <li>셀룰러 트래픽은 시공간 확률 과정으로 표현됨</li>
      <li>특정 시공간 점에서의 트래픽:</li>
    </ul>
  </li>
</ul>

\[y(s, t) \sim Y(s, t) \tag{1}\]

<ul>
  <li>\(s\): 공간 인덱스</li>
  <li>
    <p>\(t\): 시간 인덱스</p>
  </li>
  <li>확률적 과정 정의:</li>
</ul>

\[\{Y(s, t) : s \in \mathcal{D}_{s}, t \in \mathcal{D}_{t}\}\]

<ul>
  <li>\(\mathcal{D}_{s}\): 공간 도메인으로 상호 배타적인 지역으로 나뉨</li>
  <li>
    <p>\(\mathcal{D}_{t}\): 시간 도메인으로, 동일 간격의 시간 구간으로 분할됨</p>
  </li>
  <li>Spatio Temporal Covariance Function(STCF)
    <ul>
      <li>\(E[Y(s, t) = \mu]\), 이고 \(Var[Y(s, t) = \sigma^2]  \leq \infty\)일 때 공간적 차이 \(h\)와 시간적 차이 \(u\)에 따른 공분산 함수</li>
    </ul>

\[C(s_i, s_j; t_i, t_j) = Cov[Y(s_i, t_i), Y(s_j, t_j)] = C(h, u)\]

    <ul>
      <li>\(h = s_j - s_i\): 공간적 차이</li>
      <li>
        <p>\(u = t_j = t_i\): 시간적 차이</p>
      </li>
      <li>공간적 및 시간적 공분산 함수의 특별한 경우
        <ul>
          <li>순수 공간 공분산: \(C(\mathbf{h}, 0)\)</li>
          <li>순수 시간 공분산: \(C(0, u)\)</li>
          <li>Correlation 함수: \(\rho(\mathbf{h}, u) = C(\mathbf{h}, u) / \sigma^2\)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Emperical STCF</li>
</ul>

\[\hat{C}(h, u) = \frac{1}{|N_h|} \frac{1}{|N_u|} \sum_{N_h} \sum_{N_u} \big( Y(s_i, t_i) - \hat{\mu}(s_i) \big) \big( Y(s_j, t_j) - \hat{\mu}(s_j) \big)\]

<h4 id="233b-modeling-spatio-temporal-dependence">2.3.3.B Modeling Spatio-Temporal Dependence</h4>

<p>시공간 데이터를 설명하기 위해 두 가지 모델링 전략이 제안됨</p>

<ul>
  <li>
    <p><strong>독립적 모델 (Separable Model)</strong></p>
  </li>
  <li>
    <p>공간적 의존성과 시간적 의존성을 독립적으로 계산함</p>
  </li>
  <li>공분산 함수: \(C(\mathbf{h}, u) = \sigma^s \rho(\mathbf{h}) \rho(u)\)
    <ul>
      <li>\(\sigma^s\): 전체 트래픽 변동성을 나타내는 분산</li>
      <li>\(\rho(\mathbf{h})\): pure 공간적 공분산 함수</li>
      <li>\(\rho(u)\): pure 시간적 공분산 함수</li>
    </ul>
  </li>
  <li>
    <p>공간적/시간적 공분산 함수 예시</p>

    <ul>
      <li>지수 함수(Exponential)</li>
    </ul>
  </li>
</ul>

\[\rho(x) = e^{-x}, x \ge 0\]

<ul>
  <li>
    <p>거리 또는 시간 차이에 따라 상관성이 지수적으로 감소</p>

    <ul>
      <li>Cauchy 클래스(Cauchy)</li>
    </ul>
  </li>
</ul>

\[\rho(x) = (1 + x^{\alpha})^{-{\beta} \over {\alpha}}\]

<ul>
  <li>\(\alpha, \beta\): 파라미터로,상관성 감소 속도를 조정</li>
  <li>
    <p>더 유연하게 상관성 감소 패턴 설명 가능</p>
  </li>
  <li><strong>비독립적 모델 (Non-Separable Model)</strong>
    <ul>
      <li>
        <p>공간-시간 상호작용을 포함하여 복잡한 의존성을 설명</p>

        <ol>
          <li>\(\phi(x)\) - 완전 단조 함수 (Completely Monotonic Function) 정의
            <ul>
              <li>정의: 모든 차수의 도함수가 존재</li>
              <li>조건: \((-1)^{n} \phi^{n} (r) \ge 0\)</li>
            </ul>
          </li>
          <li>\(\psi(x)\) - 시간 효과 함수 (Tempoeral Effect Function) 정의
            <ul>
              <li>정의: 모든 시간 차수의 도함수가 존재</li>
            </ul>
          </li>
          <li>\(\rho(mathbf{h}, u)\) - 공분산 함수 도출
            <ul>
              <li>\(\phi(x)와 \psi(x)\)를 결합하여 비독립적 공분산 함수 정의</li>
            </ul>

\[\rho(h, u) = \frac{1}{\psi(u^2)^{d/2}} \phi\left(\frac{\|h\|^2}{\psi(u^2)}\right), \quad d &gt; 0\]
          </li>
        </ol>

        <ul>
          <li>\(\phi(x)\): 공간-시간 상호작용 설명</li>
          <li>\(\psi(x)\): 시간 효과 반영</li>
          <li>\(d\): 차원 스케일링 파라미터로 모델이 공간-시간 의존성을 조정</li>
          <li>해석: 시간적 효과(\(\psi(u^2)\))가 공분산의 스케일을 조정하고, 공간적 차이(\(\lVert h^2 \rVert\))를 통해 공간-시간 간 상호작용 포착</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Gneting-Class 모델의 주요 특징</li>
</ul>

<ol>
  <li>유연성:
    <ul>
      <li>기존 지수 함수 기반 공분산 함수보다 더 다양한 공간-시간 상호작용 패턴 설명 가능</li>
      <li>특정 시간대 또는 거리에서 상관성이 급격히 감소하거나 완만히 감소하는 상황 모두 포착 가능</li>
    </ul>
  </li>
  <li>파라미터 추정:
    <ul>
      <li>모델 파라미터 \(\Theta\)는 log-likelihood 함수 \(L(\Theta \lvert \mathbf{O})\)를 최대화하여 추정</li>
    </ul>
  </li>
</ol>

<ul>
  <li>\(\Theta\): 모델 파라미터 집합</li>
  <li>\(\mathbf{O}\): Spatio-Temporal observations</li>
</ul>

<h3 id="234-exploratory-dependence-analysis">2.3.4 Exploratory Dependence Analysis</h3>

<ol>
  <li>공간 분석 (Spatial Analysis)</li>
</ol>

<div align="center">
  <img src="/assets/img/blog/0113/fig/fig_2.png" alt="Figure 2" />
</div>

<ul>
  <li>
    <p>목적: 셀룰러 네트워크 트래픽의 공간적 의존성을 분석하여 기지국 간 거리와 트래픽의 상관성을 평가 후 공간적 비균질성(Spatial Inhormogeneity)를 이해</p>
  </li>
  <li>
    <p>분석 과정:</p>

    <ol>
      <li>기지국 단위 트래픽의 공간 밀도 분포를 분석하여 분포 특성을 파악</li>
      <li>공간적 공분산 함수 \(\rho(h, 0)\)를 계산해 거리 \(h\)에 따른 상관성 감소 패턴 분석</li>
    </ol>
  </li>
  <li>
    <p>Figure 4a: 기지국 단위 트래픽의 공간 밀도 분포</p>

    <ul>
      <li>내용:
        <ul>
          <li>각 기지국의 트래픽 용량(로그 스케일)과 해당 빈도를 나타냄</li>
          <li>대부분의 기지국이 낮거나 중간 트래픽을 처리하지만, 소수의 기지국에서 long tail로 나타나는 높은 트래픽 처리</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Figure 4b: 분포 모델 적합도 평가</p>

    <ul>
      <li>내용:
        <ul>
          <li>Weibull, Log-normal, Log-normal mixture 분포를 데이터에 피팅하고 K-S 통계를 통해 적합도 비교</li>
        </ul>
      </li>
      <li>결과:
        <ul>
          <li>Log-normal mixture 분포가 가장 적합하며, Weibull과 Log-normal은 상대적으로 덜 적합</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<div align="center">
  <img src="/assets/img/blog/0113/fig/fig_3.png" alt="Figure 3" />
</div>

<ul>
  <li>
    <p>Figure 5: 분포 모델 적합도 평가</p>

    <ul>
      <li>내용:
        <ul>
          <li>시간대(7AM, 2PM, 9PM)로 공간적 공분산 함수 \(\rho(\mathbf{h},0) \sim h^{\gamma_t}\)를 계산</li>
          <li>각 시간대에 따라 상관성이 거리 \(\mathbf{h}\)에 따라 감소하는 패턴 시각화</li>
        </ul>
      </li>
      <li>결과:
        <ul>
          <li>피크 시간대(2PM): 상관성은 약 5km까지 유지되며 이후 급격히 감소</li>
          <li>비피크 시간대(7AM, 9PM): 상관성은 약 10km까지 유지되며 더 완만히 감소
            <ul>
              <li>이는 출퇴근 및 점심시간과 같은 인간 활동 패턴에 의해 영향을 받음</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<ol>
  <li>시간 분석 (Temporal Analysis)</li>
</ol>

<ul>
  <li>목적: 시간에 따른 트래픽 변화와 의존성을 분석하여 도심과 교외 지역의 트래픽 패턴 차이를 파악</li>
  <li>분석 과정:
    <ol>
      <li>특정 지역(도심/교외)에서의 시간별 트래픽 변화를 관찰</li>
      <li>시간적 공분산 함수 \(\rho(0, u)\)를 계산해 시간 간격 \(u\)에 따른 상관성 분석</li>
    </ol>
  </li>
</ul>

<div align="center">
  <img src="/assets/img/blog/0113/fig/fig_4.png" alt="Figure 4" />
</div>

<ul>
  <li>
    <p>Figure 6a: 지역 구분</p>

    <ul>
      <li>내용:
        <ul>
          <li>분석 지역을 도심(Region A)와 교외(Region B, C)로 나눔</li>
          <li>도심은 상업 및 업무 지구, 교외는 주거 지역으로 정의</li>
          <li>이 구분을 통해 각 지역의 트래픽 패턴 차이를 분석</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Figure 6b: 시간대별 트래픽 변화</p>

    <ul>
      <li>내용:
        <ul>
          <li>도심(Region A)와 교외(Region B, C)의 시간대별 트래픽 변화 비교</li>
          <li>도심: 점심시간에 트래픽 최고치 도달</li>
          <li>교외: 하루 종일 트래픽이 꾸준히 증가</li>
          <li>이 차이는 인간의 이동 패턴과 밀접히 연결(출퇴근과 같은 “Tide Effect”)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Figure 6c &amp; 6d: 시간적 공분산 함수(\(\rho(0, u)\))</p>

    <ul>
      <li>내용:
    - 시간 간격 u에 따른 트래픽 상관성을 계산하여 도심(6c)와 교외(6d)의 패턴 비교
    - 도심: 점심시간에 상관성이 강하며, 12시간 주기에서 반복적인 상관성 관찰
    - 교외: 24시간 주기에서 강한 상관성이 유지되며, 도심보다 장기적인 패턴이 뚜렷</li>
    </ul>
  </li>
</ul>

<h3 id="235-modeling-spatial-temporal-dependence">2.3.5 Modeling Spatial-Temporal Dependence</h3>

<p>본 파트에서는 시공간 의존성을 모델링하는 방법과, 실험을 통해 각 모델의 성능을 평가한 결과를 다룬다. 특히, 공간적-시간적 상호작용을 효과적으로 반영하기 위해 독립적(Separable) 모델과 비독립적(Non-Separable) 모델을 비교하며, 각 모델의 특징 및 성능 차이를 분석한다.
 주요 내용은 아래와 같다.</p>
<ul>
  <li>모델 파라미터 추정 (Estimation of Model Parameters)</li>
  <li>모델 예측 성능 평가 (Evaluation of Prediction Performance)</li>
  <li>모델링 결과 논의 (Discussions)</li>
</ul>

<h4 id="235a-estimation-of-model-parameters">2.3.5.A Estimation of Model Parameters</h4>

<ul>
  <li>지역별 의존성 모델을 사용하여 트래픽 특성의 차이를 반영</li>
  <li>Maximum-Likelihood Estimation(MLE)으로 모델 파라미터를 학습</li>
  <li>계산 복잡성을 줄이기 위해 다음과 같은 제약을 설정
    <ul>
      <li><strong>공간적 제한</strong>: 최대 5km 거리까지의 상관성만 반영</li>
      <li><strong>시간적 제한</strong>: 최대 6시간 이전의 데이터만 예측에 활용</li>
    </ul>
  </li>
  <li>이 제한은 <strong>피크 시간대에 상관성이 급격히 감소</strong>하는 경향을 반영</li>
</ul>

<div align="center">
  <img src="/assets/img/blog/0113/fig/fig_5.png" alt="Figure 5" />
</div>

<ul>
  <li>세 가지 공분산 모델(Exponential, Cauchy-class, Gneting-class)를 교외 및 도심 지역에서 비교</li>
  <li>결과 해석
    <ul>
      <li>교외 지역:
        <ul>
          <li>공간적 거리 1km, 시간적 간격 2시간 이내에서는 세 모델 모두 높은 상관성을 보임</li>
          <li>거리 및 시간 증가 시 모델 간 상관성 감소 속도가 다름
            <ul>
              <li>Exponential, Gneting-class 모델: 완만한 감소</li>
              <li>Cauchy-class 모델: 급격한 감소</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>도심 지역:
        <ul>
          <li>시간적 상관성에서 세 모델의 차이가 두드러짐
            <ul>
              <li>Gneting-class 모델: 완만한 감소, 가장 현실적</li>
              <li>Exponential 모델: 급격한 감소</li>
              <li>Cauchy-class 모델: 보수적 감소 성향</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="235b-evaluation-of-prediction-performance">2.3.5.B Evaluation of Prediction Performance</h4>

<h5 id="예측-방식">예측 방식</h5>

<ul>
  <li>모델 파라미터는 하루 데이터를 기반으로 학습 후, 다음 6시간 동안의 트래픽을 예측</li>
  <li>공간적으로는 지역을 10x10 그리드로 나누어 N = 100 블록을 사용</li>
  <li>시간적으로는 T = 144(10분 단위)로 데이터를 분할하여 활용</li>
</ul>

<h5 id="성능-평가-지표-rmse">성능 평가 지표: RMSE</h5>

<div align="center">
  <img src="/assets/img/blog/0113/fig/fig_6.png" alt="Figure 6" />
</div>

<ul>
  <li>교외 지역
    <ul>
      <li>Gneting-class 모델의 RMSE가 2.8% - 25.2% 감소</li>
      <li>화요일과 주말은 Separable 모델이 약간 더 우수</li>
    </ul>
  </li>
  <li>도심 지역
    <ul>
      <li>Non-separable 모델이 대부분의 요일에서 RMSE를 3.7% - 23.6% 감소</li>
      <li>Non-separable 모델의 성능 우위가 더 뚜렷</li>
    </ul>
  </li>
</ul>

<div align="center">
  <img src="/assets/img/blog/0113/fig/fig_7.png" alt="Figure 7" />
</div>

<ul>
  <li>도심과 교외에서 Gneting-class 모델을 사용하여 예측한 셀룰러 트래픽과 실제 관측된 트래픽 간의 관계를 나타낸 산점도
    <ul>
      <li>점들이 대각선에 가까울수록 예측값과 실제값의 일치도가 높음을 의미</li>
    </ul>
  </li>
  <li>분석 내용
    <ul>
      <li>도심 지역
        <ul>
          <li>도심 지역의 트래픽은 중간 트래픽(0.5 - 0.75)에서 집중적으로 분포</li>
          <li>산점도가 대각선에 가까운 점들이 밀집되어 있어 예측 정확도가 높음을 확인</li>
        </ul>
      </li>
      <li>원인 및 해석
        <ul>
          <li>도심 지역의 트래픽은 공간적 밀도가 높고, 정규화된 값의 중간 범위에 데이터가 집중됨</li>
          <li>이는 Gneting-class 모델이 중간 트래픽 값에서 더 정확한 예측을 제공한다는 점을 시사</li>
        </ul>
      </li>
      <li>RMSE 결과
        <ul>
          <li>도심 지역에서 Gneting-class 모델의 RMSE는 0.137로 교외 지역보다 낮음</li>
          <li>이는 도심 지역의 트래픽 분포가 모델 학습에 유리하게 작용했음을 나타냄</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<ul>
  <li>주요 발견
    <ul>
      <li>부드러운 예측(Smoothing Effect)
        <ul>
          <li>Gneting-class 모델은 트래픽 값의 극단적인 변동을 부드럽게 조정</li>
          <li>실제값이 낮은 경우(\(x &lt; 0.25\))에는 예측값이 약간 높게 나타나고, 높은 경우 (\(x &gt; 0.75\))에는 예측값이 약간 낮아짐</li>
          <li>이는 비독립적 모델의 구조적 특성에서 기인하며 극단적인 변동성을 완화함으로써 안정적인 예측을 제공</li>
        </ul>
      </li>
      <li>도심 vs. 교외 비교:
        <ul>
          <li>도심 지역:
            <ul>
              <li>중간 트래픽 값 구간(0.5 - 0.75)에 데이터가 집중되어 모델 성능이 더 우수</li>
              <li>RMSE가 0.137로 교외보다 낮음</li>
            </ul>
          </li>
          <li>교외 지역:
            <ul>
              <li>낮은 트래픽 밀도와 넓은 공간적 범위로 인해 예측의 어려움이 더 큼</li>
              <li>RMSE가 0.154로 도심보다 약간 높음
-음</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Gneting-class 모델의 강점:
        <ul>
          <li>공간-시간 상호작용을 효과적으로 반영하여 예측 정확도 개선</li>
          <li>교외 및 도심 지역 모두에서 독립적 모델(Exponential, Cauchy-class)보다 더 낮은 RMSE를 기록</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="235c-discussions">2.3.5.C Discussions</h4>

<h5 id="separable-모델">Separable 모델</h5>

<ul>
  <li>장점
    <ul>
      <li>수학적 간결성
        <ul>
          <li>공간적 공분산 함수(\(\rho(h)\))와 시간적 공분산 함수(\(\rho(u)\))를 분리하여 계산하므로 구현이 단순하고 계산 효율적</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>한계
    <ul>
      <li>상호작용 부족
        <ul>
          <li>공간과 시간 간의 상호작용을 반영하지 못함</li>
          <li>서로 다른 시간대에서 공간적 상관성이 동일한 형태를 가지는 등 비현실적인 가정</li>
        </ul>
      </li>
      <li>조건부 상관성의 초기값 설정 문제
        <ul>
          <li>공분산 함수의 초기 조건(ex. \(\rho(h, 0)\)) 선택이 부정확할 경우, 모델링 결과가 왜곡될 가능성 존재</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="non-separable-모델">Non-Separable 모델</h5>

<ul>
  <li>장점
    <ul>
      <li>복잡한 상호작용 반영
        <ul>
          <li>공간-시간 간의 상호작용 정보를 통합하여 현실적인 셀룰러 트래픽 패턴을 포착</li>
          <li>더 복잡하고 다양한 의존성 설명 가능</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>한계
    <ul>
      <li>계산 비용
        <ul>
          <li>모델 파라미터가 많고 구조가 복잡하여 학습 시간이 더 오래 걸림</li>
        </ul>
      </li>
      <li>과적합 위험
        <ul>
          <li>모델이 역사적 데이터에 지나치게 적합할 경우, 급격한 트래픽 변화에 대응하지 못할 가능성 존재</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="한계-극복-방안">한계 극복 방안</h5>

<ol>
  <li>크로스벨리데이션 및 부트스트랩
    <ul>
      <li>과적합 문제를 해결하고 모델의 견고성을 높이기 위한 일반적인 방법</li>
      <li>다양한 데이터 샘플에 대해 반복적으로 학습 및 검증하여 모델의 신뢰성을 개선</li>
    </ul>
  </li>
  <li>클러스터 기반 의존성 모델링
    <ul>
      <li>지역별 또는 시간대 별로 서로 다른 모델을 설계
        <ul>
          <li>예: 도심과 교외 지역, 주간과 야간 시간대에 맞는 개별 모델 사용</li>
        </ul>
      </li>
      <li>이를 통해 복잡한 트래픽 패턴을 더 효과적으로 설명하며, 정확도와 견고성 간의 균형을 유지</li>
    </ul>
  </li>
</ol>

<hr />

<h5 id="주요-시사점-및-결론">주요 시사점 및 결론</h5>

<ol>
  <li>모델 선택의 중요성
    <ul>
      <li>독립적 모델은 단순성과 효율성을 제공하지만, 공간과 시간의 상호작용이 중요한 환경에서는 비독립적 모델이 필요</li>
    </ul>
  </li>
  <li>모델링 복잡성과 성능 간 균형
    <ul>
      <li>비독립적 모델은 더 높은 성능을 제공하지만, 계산 비용 증가 및 과적합 위험이 단점으로 작용</li>
      <li>크로스밸리데이션 또는 클러스터 기반 접근 방식으로 한계 보완</li>
    </ul>
  </li>
  <li>맞춤형 모델링의 필요성
    <ul>
      <li>지역 또는 시간대의 특성을 반영한 맞춤형 모델을 활용하여 정확도와 견고성을 동시에 달성</li>
    </ul>
  </li>
</ol>

<hr />

<h3 id="236-conclusion">2.3.6 Conclusion</h3>

<h4 id="연구-개요">연구 개요</h4>

<ul>
  <li>본 연구는 도시 규모의 셀룰러 트래픽 데이터를 분석하여 시공간 의존성(spatio-temporal dependence)을 탐구</li>
  <li>기존 연구가 강조했던 시간적 역학(temporal dynamics) 및 공간적 비균질성(spatial inhomogeneity)을 넘어, 두 요소 간의 상호작용을 포함한 새로운 관점을 제시</li>
</ul>

<h4 id="주요-발견">주요 발견</h4>
<ol>
  <li>공간적 관점</li>
</ol>

<ul>
  <li>셀룰러 트래픽은 이전 연구에서 가정한 uniformity을 위반</li>
  <li>이로 인해 네트워크 자원 활용에 불균형이 발생할 수 있음</li>
  <li>네트워크 시스템 설계 시 이러한 특성을 고려해야 대규모 시스템 장애를 방지 가능</li>
</ul>

<ol>
  <li>시간적 관점</li>
</ol>

<ul>
  <li>시공간 의존성을 반영한 네트워크 모듈은 혼잡을 사전에 완화할 수 있음</li>
  <li>이는 네트워크 안정성을 높이고, 운영 효율성을 개선하는 데 기여</li>
</ul>

<ol>
  <li>시공간 통합 정보의 중요성
    <ul>
      <li>공간적 및 시간적 데이터를 결합하여 상호작용 정보를 활용하면, 네트워크 시스템이 더 견고해지고 현실적인 시나리오에서 효과적으로 작동할 수 있음</li>
    </ul>
  </li>
</ol>

<h4 id="future-work">Future Work</h4>

<ul>
  <li>인간 이동성과 셀룰러 트래픽 간 연관성 연구
    <ul>
      <li>도시 내 집단적 인간 이동 패턴을 모델링</li>
      <li>트래픽의 공간적 변화와 인간 활동 간 상호작용을 정량화</li>
    </ul>
  </li>
  <li>시공간 의존성 모델 혼합
    <ul>
      <li>목표:
        <ul>
          <li>서로 다른 지역 또는 시간대의 트래픽 특성을 반영하기 위해 모델 혼합(mixture models)을 도입</li>
        </ul>
      </li>
      <li>도전과제:
        <ul>
          <li>효율적인 경계 탐지 알고리즘 개발
            <ul>
              <li>특정 모델 파라미터를 추정할 수 있는 시공간 경계를 자동으로 감지</li>
            </ul>
          </li>
          <li>효율적인 모델 결합 알고리즘
            <ul>
              <li>여러 모델을 통합하여 계산 비용을 줄이고, 높은 성능을 유지</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h1 id="3-take-away">3. Take Away</h1>
<ul>
  <li>셀룰러 트래픽은 공간적 및 시간적 특성이 복잡하게 얽혀 있으며, 이를 반영한 네트워크 모델링이 필수적</li>
  <li>인간 이동 패턴과 결합한 분석, 또는 지역별 맞춤형 모델링이 향후 연구의 중요한 방향으로 제시됨</li>
  <li>시공간 경계 탐지 및 효율적인 모델 결합 알고리즘은 이렇나 연구를 뒷받침하는 핵심 기술이 될 것</li>
</ul>]]></content><author><name>&lt;firstname&gt; &lt;lastname&gt;</name><email>&lt;mail@domain.tld&gt;</email></author><category term="paper" /><summary type="html"><![CDATA[**Date**: 2015.06.12 **Tag**: [Spatil-temporal dependence], [Traffic modeling], [Model measurement], [Correlation analysis], [Tide effects]]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/blog/0113/thumbnail/c2tm.png" /><media:content medium="image" url="http://localhost:4000/assets/img/blog/0113/thumbnail/c2tm.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">오프로딩 시뮬레이터 - Predictor</title><link href="http://localhost:4000/blog/sim/2024-12-27-offloading-predictor/" rel="alternate" type="text/html" title="오프로딩 시뮬레이터 - Predictor" /><published>2024-12-27T00:00:00+09:00</published><updated>2024-12-27T00:00:00+09:00</updated><id>http://localhost:4000/blog/sim/offloading-predictor</id><content type="html" xml:base="http://localhost:4000/blog/sim/2024-12-27-offloading-predictor/"><![CDATA[<!--more-->

<ul class="large-only" id="markdown-toc">
  <li><a href="#5g-셀-시뮬레이터-구현-가이드-trafficcollectorspredictorpy" id="markdown-toc-5g-셀-시뮬레이터-구현-가이드-trafficcollectorspredictorpy">5G 셀 시뮬레이터 구현 가이드: <code class="language-plaintext highlighter-rouge">traffic/collectors/predictor.py</code></a>    <ul>
      <li><a href="#1-아키텍쳐-개요" id="markdown-toc-1-아키텍쳐-개요">1. 아키텍쳐 개요</a>        <ul>
          <li><a href="#11-핵심-구조" id="markdown-toc-11-핵심-구조">1.1 핵심 구조</a></li>
          <li><a href="#12-주요-컴포넌트" id="markdown-toc-12-주요-컴포넌트">1.2 주요 컴포넌트</a></li>
          <li><a href="#13-데이터-흐름" id="markdown-toc-13-데이터-흐름">1.3 데이터 흐름</a></li>
        </ul>
      </li>
      <li><a href="#2-코드-설명" id="markdown-toc-2-코드-설명">2. 코드 설명</a>        <ul>
          <li><a href="#21-basepredictorbase_predictorpy" id="markdown-toc-21-basepredictorbase_predictorpy">2.1 BasePredictor(base_predictor.py)</a></li>
          <li><a href="#22-arimapredictorarima_predictorpy" id="markdown-toc-22-arimapredictorarima_predictorpy">2.2 ARIMApredictor(arima_predictor.py)</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="5g-셀-시뮬레이터-구현-가이드-trafficcollectorspredictorpy">5G 셀 시뮬레이터 구현 가이드: <code class="language-plaintext highlighter-rouge">traffic/collectors/predictor.py</code></h1>

<h2 id="1-아키텍쳐-개요">1. 아키텍쳐 개요</h2>

<h3 id="11-핵심-구조">1.1 핵심 구조</h3>
<ul>
  <li>최상위 추상 클래스 (BasePredictor)</li>
  <li>구체적인 구현 클래스들 (ArimaPredictor, ProphetPredictor 등)</li>
  <li>모듈식 설계
    <ul>
      <li>예측기 컴포넌트</li>
      <li>데이터 수집기 컴포넌트</li>
      <li>전처리기 컴포넌트</li>
      <li>정확도 검증 컴포넌트</li>
    </ul>
  </li>
</ul>

<h3 id="12-주요-컴포넌트">1.2 주요 컴포넌트</h3>

<ol>
  <li>BasePredictor: 모든 예측기의 기본이 되는 추상 클래스. 예측기가 구연해야 할 핵심 메서드들을 정의</li>
  <li>ArimaPredictor: 시계열 데이터 분석에 널리 사용되는 ARIMA 모델을 구현한 예측기</li>
  <li>ProphetPredictor: 시계열 데이터 분석에 널리 사용되는 Facebook Prophet 모델을 구현한 예측기</li>
  <li>추가 예정</li>
</ol>

<h3 id="13-데이터-흐름">1.3 데이터 흐름</h3>

<ol>
  <li>데이터 수집
    <ul>
      <li>Cell 컴포넌트에서 트래픽 데이터 수집</li>
      <li>FrequencyCollector를 통한 주파수별 데이터 집계</li>
    </ul>
  </li>
  <li>전처리
    <ul>
      <li>DataPreprocessor를 통한 데이터 정규화</li>
      <li>결측치 및 이상치 처리</li>
    </ul>
  </li>
  <li>예측 수행
    <ul>
      <li>선택된 예측기를 통한 미래 트래픽 예측</li>
      <li>예측 결과의 신뢰도 평가</li>
    </ul>
  </li>
  <li>결과 활용
    <ul>
      <li>RIC에서 예측 결과를 기반으로 자원 할당 최적화</li>
      <li>Cell에서 주파수 활성화/비활성호 결정</li>
    </ul>
  </li>
</ol>

<h2 id="2-코드-설명">2. 코드 설명</h2>

<h3 id="21-basepredictorbase_predictorpy">2.1 BasePredictor(base_predictor.py)</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BasePredictor</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="s">"""
    모든 예측기의 기본이 되는 추상 클래스
    새로운 예측 알고리즘을 추가할 때는 이 클래스를 상속받아 구현 예정
    
    주요 메서드:
    - train: 모델 학습
    - predict: 예측 수행
    - update: 모델 업데이트
    """</span>
</code></pre></div></div>

<h3 id="22-arimapredictorarima_predictorpy">2.2 ARIMApredictor(arima_predictor.py)</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ArimaPredictor</span><span class="p">(</span><span class="n">BasePredictor</span><span class="p">):</span>
    <span class="s">"""
    ARIMA 모델을 활용한 예측기입니다.
    
    특징:
    - 단기 예측에 적합
    - 추세와 계절성을 고려한 예측 가능
    - 자기회귀 및 이동평균 특성 활용
    
    주의사항:
    - order 파라미터 설정이 중요 (p,d,q)
    - 데이터의 정상성 가정 필요
    """</span>
</code></pre></div></div>]]></content><author><name>&lt;firstname&gt; &lt;lastname&gt;</name><email>&lt;mail@domain.tld&gt;</email></author><category term="sim" /><summary type="html"><![CDATA[**Date**: 2024.12.27, **Tag**: [Offloading], [Patent], [Multi Frequency Band]]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/blog/sim/phase1/sim.png" /><media:content medium="image" url="http://localhost:4000/assets/img/blog/sim/phase1/sim.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">오프로딩 시뮬레이터 - Collector</title><link href="http://localhost:4000/blog/sim/2024-12-27-offloading-collector/" rel="alternate" type="text/html" title="오프로딩 시뮬레이터 - Collector" /><published>2024-12-27T00:00:00+09:00</published><updated>2024-12-27T00:00:00+09:00</updated><id>http://localhost:4000/blog/sim/offloading-collector</id><content type="html" xml:base="http://localhost:4000/blog/sim/2024-12-27-offloading-collector/"><![CDATA[<!--more-->

<ul class="large-only" id="markdown-toc">
  <li><a href="#5g-셀-시뮬레이터-구현-가이드-trafficcollectorsfrequency_collectorpy" id="markdown-toc-5g-셀-시뮬레이터-구현-가이드-trafficcollectorsfrequency_collectorpy">5G 셀 시뮬레이터 구현 가이드: <code class="language-plaintext highlighter-rouge">traffic/collectors/frequency_collector.py</code></a>    <ul>
      <li><a href="#1-아키텍쳐-개요" id="markdown-toc-1-아키텍쳐-개요">1. 아키텍쳐 개요</a>        <ul>
          <li><a href="#11-핵심-구조" id="markdown-toc-11-핵심-구조">1.1 핵심 구조</a></li>
          <li><a href="#12-주요-컴포넌트" id="markdown-toc-12-주요-컴포넌트">1.2 주요 컴포넌트</a></li>
          <li><a href="#13-데이터-흐름" id="markdown-toc-13-데이터-흐름">1.3 데이터 흐름</a></li>
        </ul>
      </li>
      <li><a href="#2-코드-설명" id="markdown-toc-2-코드-설명">2. 코드 설명</a>        <ul>
          <li><a href="#21-basecollector-클래스" id="markdown-toc-21-basecollector-클래스">2.1 BaseCollector 클래스</a></li>
          <li><a href="#22-frequencycollector-클래스" id="markdown-toc-22-frequencycollector-클래스">2.2 FrequencyCollector 클래스</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="5g-셀-시뮬레이터-구현-가이드-trafficcollectorsfrequency_collectorpy">5G 셀 시뮬레이터 구현 가이드: <code class="language-plaintext highlighter-rouge">traffic/collectors/frequency_collector.py</code></h1>

<h2 id="1-아키텍쳐-개요">1. 아키텍쳐 개요</h2>

<h3 id="11-핵심-구조">1.1 핵심 구조</h3>
<ul>
  <li>추상 기본 클래스(BaseCollector)를 중심으로 한 계층적 설계</li>
  <li>구체적인 수집기들이 BaseCollector를 상속받아 구현</li>
  <li>모듈식 구조로 새로운 수집기 타입 확장 용이</li>
</ul>

<h3 id="12-주요-컴포넌트">1.2 주요 컴포넌트</h3>
<ul>
  <li>BaseCollector: 데이터 수집의 기본 프레임워크 제공
    <ul>
      <li>공통 속성 및 메서드 정의</li>
      <li>데이터 버퍼링 메커니즘 구현</li>
      <li>수집 주기 관리 기능</li>
    </ul>
  </li>
  <li>FrequencyCollector: 주파수 관련 데이터 수집 담당
    <ul>
      <li>Resource Block 사용률 모니터링</li>
      <li>UE 연결 상태 추적</li>
      <li>처리량 계산 및 기록</li>
    </ul>
  </li>
</ul>

<h3 id="13-데이터-흐름">1.3 데이터 흐름</h3>
<ul>
  <li>실시간 데이터 수집 $\rightarrow$ 임시 버퍼 저장 $\rightarrow$ 구조화된 데이터 형태로 변환</li>
  <li>시계열 데이터 형식으로 타임스탬프 정보 포함</li>
  <li>주기적인 데이터 수집 및 저장 보장</li>
</ul>

<h2 id="2-코드-설명">2. 코드 설명</h2>

<h3 id="21-basecollector-클래스">2.1 BaseCollector 클래스</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BaseCollector</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">sampling_interval</span> <span class="o">=</span> <span class="n">sampling_interval</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">last_collection_time</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div></div>

<ul>
  <li>초기화 부분은 데이터 수집의 기본 설정을 담당</li>
  <li><code class="language-plaintext highlighter-rouge">sampling_interval</code>: 데이터 수집 주기 설정 (기본값 10초)</li>
  <li><code class="language-plaintext highlighter-rouge">last_collection_time</code>: 마지막 데이터 수집 시간 추적</li>
  <li><code class="language-plaintext highlighter-rouge">_buffer</code>: 수집된 데이터를 임시 저장하는 리스트</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">buffer_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">timestamp</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">()</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">_buffer</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
</code></pre></div></div>

<ul>
  <li>수집된 데이터를 타임스탬프와 함께 버퍼에 저장</li>
  <li>데이터의 시간 순서를 보장하고 추후 분석을 위한 시계열 데이터 구조 생성</li>
</ul>

<h3 id="22-frequencycollector-클래스">2.2 FrequencyCollector 클래스</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FrequencyCollector</span><span class="p">(</span><span class="n">BaseCollector</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">(</span><span class="n">sampling_interval</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">cell</span> <span class="o">=</span> <span class="n">cell</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">frequencies</span> <span class="o">=</span> <span class="n">cell</span><span class="p">.</span><span class="n">freq_config</span><span class="p">.</span><span class="n">keys</span><span class="p">()</span>
</code></pre></div></div>

<ul>
  <li>BaseCollector를 상속받아 주파수별 데이터 수집에 특화된 기능 구현</li>
  <li><code class="language-plaintext highlighter-rouge">cell</code>: 데이터를 수집할 셀 객체</li>
  <li><code class="language-plaintext highlighter-rouge">frequencies</code>: 모니터링할 주파수 대역 목록</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">traffic_data</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">frequencies</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">cell</span><span class="p">.</span><span class="n">freq_config</span><span class="p">[</span><span class="n">freq</span><span class="p">][</span><span class="s">'active'</span><span class="p">]:</span>
            <span class="n">rb_usage</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">cell</span><span class="p">.</span><span class="n">get_frequency_load</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
            <span class="n">connected_ues</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">cell</span><span class="p">.</span><span class="n">get_frequency_users</span><span class="p">(</span><span class="n">freq</span><span class="p">))</span>
            <span class="n">throughput</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">calculate_frequency_throughput</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
            
            <span class="n">traffic_data</span><span class="p">[</span><span class="n">freq</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s">'rb_usage'</span><span class="p">:</span> <span class="n">rb_usage</span><span class="p">,</span>
                <span class="s">'connected_ues'</span><span class="p">:</span> <span class="n">connected_ues</span><span class="p">,</span>
                <span class="s">'throughput'</span><span class="p">:</span> <span class="n">throughput</span>
            <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>각 활성화된 주파수 대역에 대해 다음 데이터를 수집:
    <ol>
      <li>Resource Block 사용률</li>
      <li>연결된 UE 수</li>
      <li>총 처리량</li>
    </ol>
  </li>
  <li>수집된 데이터는 주파수별로 구조화되어 저장</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">calculate_frequency_throughput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
    <span class="n">total_throughput</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">ue_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">cell</span><span class="p">.</span><span class="n">get_frequency_users</span><span class="p">(</span><span class="n">freq</span><span class="p">):</span>
        <span class="n">ue_throughput</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">cell</span><span class="p">.</span><span class="n">get_UE_throughput</span><span class="p">(</span><span class="n">ue_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ue_throughput</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">total_throughput</span> <span class="o">+=</span> <span class="n">ue_throughput</span>
    <span class="k">return</span> <span class="n">total_throughput</span>
</code></pre></div></div>

<ul>
  <li>특정 주파수 대역의 총 처리량 계산</li>
  <li>해당 주파수를 사용하는 모든 UE의 처리량을 합산</li>
  <li>None 값 처리를 통한 안정성 보장</li>
</ul>]]></content><author><name>&lt;firstname&gt; &lt;lastname&gt;</name><email>&lt;mail@domain.tld&gt;</email></author><category term="sim" /><summary type="html"><![CDATA[**Date**: 2024.12.27, **Tag**: [Offloading], [Patent], [Multi Frequency Band]]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/blog/sim/phase1/sim.png" /><media:content medium="image" url="http://localhost:4000/assets/img/blog/sim/phase1/sim.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">오프로딩 시뮬레이터 - Storage</title><link href="http://localhost:4000/blog/sim/2024-12-27-offloading-storage/" rel="alternate" type="text/html" title="오프로딩 시뮬레이터 - Storage" /><published>2024-12-27T00:00:00+09:00</published><updated>2024-12-27T00:00:00+09:00</updated><id>http://localhost:4000/blog/sim/offloading-storage</id><content type="html" xml:base="http://localhost:4000/blog/sim/2024-12-27-offloading-storage/"><![CDATA[<!--more-->

<ul class="large-only" id="markdown-toc">
  <li><a href="#5g-셀-시뮬레이터-구현-가이드-trafficstorage" id="markdown-toc-5g-셀-시뮬레이터-구현-가이드-trafficstorage">5G 셀 시뮬레이터 구현 가이드: <code class="language-plaintext highlighter-rouge">traffic/storage</code></a>    <ul>
      <li><a href="#1-아키텍쳐-개요" id="markdown-toc-1-아키텍쳐-개요">1. 아키텍쳐 개요</a>        <ul>
          <li><a href="#11-핵심-구조" id="markdown-toc-11-핵심-구조">1.1 핵심 구조</a></li>
          <li><a href="#12-주요-컴포넌트" id="markdown-toc-12-주요-컴포넌트">1.2 주요 컴포넌트</a></li>
          <li><a href="#13-데이터-흐름" id="markdown-toc-13-데이터-흐름">1.3 데이터 흐름</a></li>
        </ul>
      </li>
      <li><a href="#2-코드-설명" id="markdown-toc-2-코드-설명">2. 코드 설명</a>        <ul>
          <li><a href="#21-timeseriesdbtimeseries_dbpy" id="markdown-toc-21-timeseriesdbtimeseries_dbpy">2.1 TimeSeriesDB(timeseries_db.py)</a></li>
          <li><a href="#22-frequencycollectorfrequency_collectorpy" id="markdown-toc-22-frequencycollectorfrequency_collectorpy">2.2 FrequencyCollector(frequency_collector.py)</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="5g-셀-시뮬레이터-구현-가이드-trafficstorage">5G 셀 시뮬레이터 구현 가이드: <code class="language-plaintext highlighter-rouge">traffic/storage</code></h1>

<h2 id="1-아키텍쳐-개요">1. 아키텍쳐 개요</h2>

<h3 id="11-핵심-구조">1.1 핵심 구조</h3>
<ul>
  <li>계층적 저장소 시스템
    <ul>
      <li>기본 데이터 수집기 (BaseCollector)</li>
      <li>시계열 데이터베이스 관리 (TimeSeiresDB)</li>
      <li>주파수별 데이터 수집 (FrequencyCollector)</li>
    </ul>
  </li>
</ul>

<h3 id="12-주요-컴포넌트">1.2 주요 컴포넌트</h3>
<ol>
  <li>시계열 데이터베이스 (TimeSeiresDB)
    <ul>
      <li>SQLite 기반의 경량 데이터베이스</li>
      <li>트래픽 데이터의 시계열 저장</li>
      <li>효율적인 쿼리 처리</li>
    </ul>
  </li>
  <li>주파수 수집기 (FrequencyCollector)
    <ul>
      <li>주파수별 트래픽 데이터 수집</li>
      <li>실시간 데이터 처리</li>
      <li>메모리 효율적 버퍼링</li>
    </ul>
  </li>
</ol>

<h3 id="13-데이터-흐름">1.3 데이터 흐름</h3>

<ol>
  <li>
    <p>데이터 수집
Cell 데이터 생성 $\rightarrow$ FrequencyCollector 수집 $\rightarrow$ 임시 버퍼 저장 $\rightarrow$ TimeSeriesDB 저장</p>
  </li>
  <li>
    <p>데이터 조회
쿼리 요청 $\rightarrow$ TimeSeriesDB 검색 $\rightarrow$ 데이터 전처리 $\rightarrow$ 결과 반환</p>
  </li>
</ol>

<h2 id="2-코드-설명">2. 코드 설명</h2>

<h3 id="21-timeseriesdbtimeseries_dbpy">2.1 TimeSeriesDB(timeseries_db.py)</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TimeSeriesDB</span><span class="p">:</span>
    <span class="s">"""
    시계열 데이터 저장소
    
    주요 기능:
    - SQLite 기반 데이터 저장
    - 효율적인 시계열 데이터 관리
    - 셀별/주파수별 데이터 조회
    
    사용 예시:
    db = TimeSeriesDB('traffic.db')
    db.store_traffic_data(cell_id=1, data=traffic_data)
    cell_data = db.get_cell_data(cell_id=1)
    """</span>
</code></pre></div></div>

<ol>
  <li>테이블 스키마 설계
    <ul>
      <li>timestamp: 데이터 수집 시간</li>
      <li>cell_id: 셀 식별자</li>
      <li>frequency: 주파수 대역들</li>
      <li>metrics: 성능 지표</li>
    </ul>
  </li>
</ol>

<h3 id="22-frequencycollectorfrequency_collectorpy">2.2 FrequencyCollector(frequency_collector.py)</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FrequencyCollector</span><span class="p">:</span>
    <span class="s">"""
    주파수별 트래픽 데이터 수집기
    
    주요 기능:
    - 실시간 트래픽 데이터 수집
    - 주파수별 데이터 분류
    - 효율적인 메모리 관리
    
    사용 예시:
    collector = FrequencyCollector(cell, sampling_interval=1.0)
    data = collector.collect()
    """</span>
</code></pre></div></div>

<ol>
  <li>샘플링 전략
    <ul>
      <li>적절한 샘플링 간격 설정</li>
      <li>데이터 정확성과 저장 공간의 균형</li>
    </ul>
  </li>
  <li>메모리 관리
    <ul>
      <li>순환 버퍼 사용</li>
      <li>주기적인 데이터 플러시</li>
    </ul>
  </li>
</ol>]]></content><author><name>&lt;firstname&gt; &lt;lastname&gt;</name><email>&lt;mail@domain.tld&gt;</email></author><category term="sim" /><summary type="html"><![CDATA[**Date**: 2024.12.27, **Tag**: [Offloading], [Patent], [Multi Frequency Band]]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/blog/sim/phase1/sim.png" /><media:content medium="image" url="http://localhost:4000/assets/img/blog/sim/phase1/sim.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">오프로딩 시뮬레이터 - Pathloss</title><link href="http://localhost:4000/blog/sim/2024-12-26-offloading-pathloss/" rel="alternate" type="text/html" title="오프로딩 시뮬레이터 - Pathloss" /><published>2024-12-26T00:00:00+09:00</published><updated>2024-12-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/sim/offloading-pathloss</id><content type="html" xml:base="http://localhost:4000/blog/sim/2024-12-26-offloading-pathloss/"><![CDATA[<!--more-->

<ul class="large-only" id="markdown-toc">
  <li><a href="#5g-셀-시뮬레이터-구현-가이드-utilspathlosspy" id="markdown-toc-5g-셀-시뮬레이터-구현-가이드-utilspathlosspy">5G 셀 시뮬레이터 구현 가이드: <code class="language-plaintext highlighter-rouge">utils/pathloss.py</code></a>    <ul>
      <li><a href="#1-아키텍쳐-개요" id="markdown-toc-1-아키텍쳐-개요">1. 아키텍쳐 개요</a></li>
      <li><a href="#2-코드-설명" id="markdown-toc-2-코드-설명">2. 코드 설명</a>        <ul>
          <li><a href="#2-주파수-설정" id="markdown-toc-2-주파수-설정">2. 주파수 설정</a></li>
          <li><a href="#3-트래픽-예측" id="markdown-toc-3-트래픽-예측">3. 트래픽 예측</a></li>
          <li><a href="#4-에너지-소비-관리" id="markdown-toc-4-에너지-소비-관리">4. 에너지 소비 관리</a></li>
          <li><a href="#5-셀-상태-관리" id="markdown-toc-5-셀-상태-관리">5. 셀 상태 관리</a></li>
          <li><a href="#6-성능-측정-및-보고" id="markdown-toc-6-성능-측정-및-보고">6. 성능 측정 및 보고</a></li>
          <li><a href="#7-참고문헌" id="markdown-toc-7-참고문헌">7. 참고문헌</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="5g-셀-시뮬레이터-구현-가이드-utilspathlosspy">5G 셀 시뮬레이터 구현 가이드: <code class="language-plaintext highlighter-rouge">utils/pathloss.py</code></h1>

<h2 id="1-아키텍쳐-개요">1. 아키텍쳐 개요</h2>

<ul>
  <li>3GPP 표준에 정의된 경로손실 모델 구현</li>
  <li>주파수 대역별 최적 모델 선택</li>
  <li>도시 환경(Urban Macro/Micro) 지원</li>
  <li>LOS/NLOS 시나리오 고려</li>
  <li>정확한 전파 특성 예측</li>
</ul>

<h2 id="2-코드-설명">2. 코드 설명</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">h_BS</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span> 
             <span class="n">MIMO_gain_dB</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">f_callback</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
             <span class="n">f_callback_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">.</span><span class="n">i</span>
    <span class="n">Cell</span><span class="p">.</span><span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">interval</span> <span class="o">=</span> <span class="n">interval</span>
    
    <span class="c1"># 트래픽 예측 관련 설정
</span>    <span class="bp">self</span><span class="p">.</span><span class="n">traffic_predictor</span> <span class="o">=</span> <span class="n">ProphetPredictor</span><span class="p">()</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">traffic_db</span> <span class="o">=</span> <span class="n">TimeseriesDB</span><span class="p">()</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">prediction_horizon</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># 10초 (1초 * 10)
</span></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sim</code>: 메인 시뮬레이터 인스턴스를 전달받음. 이를 통해 전체 시뮬레이션 환경에 접근할 수 있음</li>
  <li><code class="language-plaintext highlighter-rouge">interval</code>: 셀의 상태 업데이트 주기를 설정. 기본값은 1초</li>
  <li><code class="language-plaintext highlighter-rouge">traffic_predictor</code>: 트래픽 예측기를 초기화</li>
  <li><code class="language-plaintext highlighter-rouge">prediction_horizon</code>: 10으로 설정하여 10초 앞의 트래픽을 예측</li>
</ul>

<p class="note">중요 포인트</p>
<ul>
  <li>Cell.i는 셀 식별자로 사용되며, 생성될 때마다 자동으로 증가한다.</li>
  <li>ProphetPredictor는 별도의 클래스로 구현되어 있으며, 시계열 예측을 담당한다.</li>
</ul>

<h4 id="2-주파수-설정">2. 주파수 설정</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 주파수 설정
</span><span class="bp">self</span><span class="p">.</span><span class="n">freq_config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">800</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'bandwidth'</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">,</span>  <span class="c1"># MHz
</span>        <span class="s">'n_RBs'</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>       <span class="c1"># Resource Blocks
</span>        <span class="s">'active'</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
        <span class="s">'energy_consumed'</span><span class="p">:</span> <span class="mf">0.0</span>
    <span class="p">},</span>
    <span class="mi">1800</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'bandwidth'</span><span class="p">:</span> <span class="mf">20.0</span><span class="p">,</span>
        <span class="s">'n_RBs'</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s">'active'</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
        <span class="s">'energy_consumed'</span><span class="p">:</span> <span class="mf">0.0</span>
    <span class="p">},</span>
    <span class="mi">3600</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'bandwidth'</span><span class="p">:</span> <span class="mf">100.0</span><span class="p">,</span>
        <span class="s">'n_RBs'</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
        <span class="s">'active'</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
        <span class="s">'energy_consumed'</span><span class="p">:</span> <span class="mf">0.0</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>각 주파수 대역별로 다음 파라미터를 설정
    <ul>
      <li><code class="language-plaintext highlighter-rouge">bandwidth</code>: MHz</li>
      <li><code class="language-plaintext highlighter-rouge">n_RBs</code>: Resource Block 수</li>
      <li><code class="language-plaintext highlighter-rouge">active</code>: 활성화 여부</li>
      <li><code class="language-plaintext highlighter-rouge">energy_consumed</code>: 에너지 소비량</li>
    </ul>
  </li>
</ul>

<p class="note">중요 포인트</p>
<ul>
  <li>800MHz: 커버리지가 넓지만 용량이 적음</li>
  <li>1800MHz: 중간 대역으로 커버리지와 용량의 균형을 제공</li>
  <li>3600MHz: mmWave 대역으로 높은 용량을 제공하지만 커버리지가 제한적</li>
</ul>

<h4 id="3-트래픽-예측">3. 트래픽 예측</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">predict_traffic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">traffic_history</span><span class="p">[</span><span class="n">freq</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>  <span class="c1"># 최소 10초의 데이터 필요
</span>        <span class="k">return</span> <span class="bp">None</span>
        
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="s">'ds'</span><span class="p">:</span> <span class="n">pd</span><span class="p">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">end</span><span class="o">=</span><span class="n">pd</span><span class="p">.</span><span class="n">Timestamp</span><span class="p">.</span><span class="n">now</span><span class="p">(),</span> 
                          <span class="n">periods</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">traffic_history</span><span class="p">[</span><span class="n">freq</span><span class="p">]),</span> 
                          <span class="n">freq</span><span class="o">=</span><span class="s">'15T'</span><span class="p">),</span>
        <span class="s">'y'</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">traffic_history</span><span class="p">[</span><span class="n">freq</span><span class="p">]</span>
    <span class="p">})</span>
    
    <span class="bp">self</span><span class="p">.</span><span class="n">traffic_predictor</span><span class="p">.</span><span class="n">train</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">forecast</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">traffic_predictor</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">prediction_horizon</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">forecast</span><span class="p">[</span><span class="s">'yhat'</span><span class="p">].</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">traffic_history</code>: 각 주파수별 트래픽 이력을 저장</li>
  <li>최소 10초(10개의 샘플)의 데이터가 필요</li>
  <li>Prophet 모델의 입력 형식에 맞게 DataFrame을 구성</li>
  <li>예측 결과의 마지막 값을 반환</li>
</ul>

<p class="note">중요 포인트</p>
<ul>
  <li>Prophet 모델은 <code class="language-plaintext highlighter-rouge">ds</code>와 <code class="language-plaintext highlighter-rouge">y</code> 컬럼을 필요로 함</li>
  <li>10초 간격으로 데이터를 샘플링</li>
  <li>예측값이 없는 경우 None을 반환</li>
</ul>

<h4 id="4-에너지-소비-관리">4. 에너지 소비 관리</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update_energy_consumption</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">interval_hours</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">interval</span> <span class="o">/</span> <span class="mi">3600</span>  <span class="c1"># 초를 시간으로 변환
</span>    <span class="n">energy</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">base_power_W</span> <span class="o">*</span> <span class="n">interval_hours</span>
    
    <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">freq_config</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">freq_config</span><span class="p">[</span><span class="n">freq</span><span class="p">][</span><span class="s">'active'</span><span class="p">]:</span>
            <span class="n">freq_energy</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">frequency_power_W</span> <span class="o">*</span> <span class="n">interval_hours</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">freq_config</span><span class="p">[</span><span class="n">freq</span><span class="p">][</span><span class="s">'energy_consumed'</span><span class="p">]</span> <span class="o">+=</span> <span class="n">freq_energy</span>
            <span class="n">energy</span> <span class="o">+=</span> <span class="n">freq_energy</span>
            
    <span class="bp">self</span><span class="p">.</span><span class="n">total_energy_consumed</span> <span class="o">+=</span> <span class="n">energy</span>
</code></pre></div></div>
<ul>
  <li>기본 전력 소비(<code class="language-plaintext highlighter-rouge">base_power_W</code>)와 주파수별 추가 전력 소비를 계산</li>
  <li>시간 단위로 변환하여 에너지 소비량을 계산</li>
  <li>각 주파수 대역별 에너지 소비를 누적하여 기록</li>
</ul>

<p class="note">중요 포인트</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">interval_hours</code>: 초 단위를 시간 단위로 변환</li>
  <li><code class="language-plaintext highlighter-rouge">base_power_W</code>: 기본 소비 전력 (130W)</li>
  <li><code class="language-plaintext highlighter-rouge">frequency_power_W</code>: 주파수 당 추가 소비 전력 (100W)</li>
</ul>

<h4 id="5-셀-상태-관리">5. 셀 상태 관리</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">manage_cell_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">freq_config</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">freq_config</span><span class="p">[</span><span class="n">freq</span><span class="p">][</span><span class="s">'active'</span><span class="p">]:</span>
            <span class="k">continue</span>
            
        <span class="n">current_load</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_frequency_load</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="n">predicted_load</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">predict_traffic</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">predicted_load</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">continue</span>
            
        <span class="k">if</span> <span class="p">(</span><span class="n">current_load</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">traffic_thresholds</span><span class="p">[</span><span class="n">freq</span><span class="p">][</span><span class="s">'low'</span><span class="p">]</span> <span class="ow">and</span> 
            <span class="n">predicted_load</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">traffic_thresholds</span><span class="p">[</span><span class="n">freq</span><span class="p">][</span><span class="s">'low'</span><span class="p">]):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">can_shift_traffic</span><span class="p">(</span><span class="n">freq</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">deactivate_frequency</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">redistribute_traffic</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">current_load</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">traffic_thresholds</span><span class="p">[</span><span class="n">freq</span><span class="p">][</span><span class="s">'high'</span><span class="p">]</span> <span class="ow">or</span> 
              <span class="n">predicted_load</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">traffic_thresholds</span><span class="p">[</span><span class="n">freq</span><span class="p">][</span><span class="s">'high'</span><span class="p">]):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">activate_frequency</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>각 주파수 대역의 현재 부하와 예측 부하를 확인</li>
  <li>트래픽 임계값을 기준으로 주파수 활성화/비활성화를 결정</li>
  <li>트래픽 재분배 가능 여부를 확인 후 실행</li>
</ul>

<ul class="note">
  <li><code class="language-plaintext highlighter-rouge">traffic_thresholds</code>: 주파수별 저부하/고부하 임계값</li>
  <li><code class="language-plaintext highlighter-rouge">can_shift_traffic</code>: 트래픽 재분배 가능 여부를 확인하고, 분배 가능 여부을 반환</li>
  <li><code class="language-plaintext highlighter-rouge">redistribute_traffic</code>: 실제 트래픽 재분배를 수행</li>
</ul>

<h4 id="6-성능-측정-및-보고">6. 성능 측정 및 보고</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s">'throughput'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">'current'</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">metrics</span><span class="p">[</span><span class="s">'throughput'</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">metrics</span><span class="p">[</span><span class="s">'throughput'</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s">'average'</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">metrics</span><span class="p">[</span><span class="s">'throughput'</span><span class="p">])</span> <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">metrics</span><span class="p">[</span><span class="s">'throughput'</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="p">},</span>
        <span class="s">'energy'</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_energy_stats</span><span class="p">(),</span>
        <span class="s">'load'</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">freq</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_frequency_load</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">freq_config</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>처리량, 에너지 소비, 부하 등의 주요 성능 지표를 수집</li>
  <li>현재값과 평균값을 함께 제공</li>
  <li>주파수별 세부 통계를 포함</li>
</ul>

<p class="note">중요 포인트</p>
<ul>
  <li>처리량은 가장 최근값과 평균값을 제공</li>
  <li>에너지 통계는 총 소비량과 주파수별 소비량 포함</li>
  <li>부하는 각 주파수 대역별로 계산</li>
</ul>

<h4 id="7-참고문헌">7. 참고문헌</h4>
<ol>
  <li>Path Loss Models: 3GPP TR 38.901</li>
  <li>QoS 관리: 3GPP TS 23.501</li>
  <li>주파수 자원 관리: TS 38.211</li>
</ol>]]></content><author><name>&lt;firstname&gt; &lt;lastname&gt;</name><email>&lt;mail@domain.tld&gt;</email></author><category term="sim" /><summary type="html"><![CDATA[**Date**: 2024.12.26, **Tag**: [Offloading], [Patent], [Multi Frequency Band]]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/blog/sim/phase1/sim.png" /><media:content medium="image" url="http://localhost:4000/assets/img/blog/sim/phase1/sim.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">오프로딩 시뮬레이터 - Logger</title><link href="http://localhost:4000/blog/sim/2024-12-26-offloading-logger/" rel="alternate" type="text/html" title="오프로딩 시뮬레이터 - Logger" /><published>2024-12-26T00:00:00+09:00</published><updated>2024-12-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/sim/offloading-logger</id><content type="html" xml:base="http://localhost:4000/blog/sim/2024-12-26-offloading-logger/"><![CDATA[<!--more-->

<ul class="large-only" id="markdown-toc">
  <li><a href="#5g-셀-시뮬레이터-구현-가이드-utilsloggerpy" id="markdown-toc-5g-셀-시뮬레이터-구현-가이드-utilsloggerpy">5G 셀 시뮬레이터 구현 가이드: <code class="language-plaintext highlighter-rouge">utils/logger.py</code></a>    <ul>
      <li><a href="#1-아키텍쳐-개요" id="markdown-toc-1-아키텍쳐-개요">1. 아키텍쳐 개요</a></li>
      <li><a href="#2-코드-설명" id="markdown-toc-2-코드-설명">2. 코드 설명</a>        <ul>
          <li><a href="#1-기본-로깅-기능" id="markdown-toc-1-기본-로깅-기능">1. 기본 로깅 기능</a></li>
          <li><a href="#2-이벤트-로깅" id="markdown-toc-2-이벤트-로깅">2. 이벤트 로깅</a></li>
          <li><a href="#3-메트릭-관리" id="markdown-toc-3-메트릭-관리">3. 메트릭 관리</a></li>
          <li><a href="#4-네트워크-상태-로깅" id="markdown-toc-4-네트워크-상태-로깅">4. 네트워크 상태 로깅</a></li>
          <li><a href="#5-메트릭-시각화" id="markdown-toc-5-메트릭-시각화">5. 메트릭 시각화</a></li>
          <li><a href="#6-유틸리티-함수" id="markdown-toc-6-유틸리티-함수">6. 유틸리티 함수</a></li>
          <li><a href="#7-네트워크-시각화" id="markdown-toc-7-네트워크-시각화">7. 네트워크 시각화</a>            <ul>
              <li><a href="#71-주파수-대역별-커버리지-시각화" id="markdown-toc-71-주파수-대역별-커버리지-시각화">7.1 주파수 대역별 커버리지 시각화</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="5g-셀-시뮬레이터-구현-가이드-utilsloggerpy">5G 셀 시뮬레이터 구현 가이드: <code class="language-plaintext highlighter-rouge">utils/logger.py</code></h1>

<h2 id="1-아키텍쳐-개요">1. 아키텍쳐 개요</h2>

<p><code class="language-plaintext highlighter-rouge">logger.py</code>는 시뮬레이션 중 발생하는 이벤트, 메트릭, 디버그 정보를 체계적으로 기록하고 관리하는 부분임. 주요 컴포넌트는 아래와 같음.</p>

<ul>
  <li>파일/콘솔 로깅 지원</li>
  <li>로그 파일 자동 순환</li>
  <li>시계열 메트릭 저장</li>
  <li>메트릭 시각화</li>
  <li>다양한 로깅 레벨</li>
</ul>

<hr />

<h2 id="2-코드-설명">2. 코드 설명</h2>

<h3 id="1-기본-로깅-기능">1. 기본 로깅 기능</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
             <span class="n">log_dir</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">'logs'</span><span class="p">,</span>
             <span class="n">level</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">'INFO'</span><span class="p">,</span>
             <span class="n">console_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
             <span class="n">file_output</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
             <span class="n">rotation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">'size'</span><span class="p">,</span>
             <span class="n">max_bytes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">,</span>  <span class="c1"># 10MB
</span>             <span class="n">backup_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">):</span>
    <span class="s">"""
    Parameters
    ----------
    name : str
        로거 이름
    log_dir : str
        로그 파일 저장 디렉토리
    level : str
        로깅 레벨 ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL')
    console_output : bool
        콘솔 출력 여부
    file_output : bool
        파일 출력 여부
    rotation : str
        로그 순환 방식 ('size' 또는 'time')
    max_bytes : int
        최대 로그 파일 크기
    backup_count : int
        보관할 백업 파일 수
    """</span>
</code></pre></div></div>

<ul>
  <li>핵심 초기화 파라미터
    <ul>
      <li>name: logger 식별자</li>
      <li>log_dir: 로그 저장 위치</li>
      <li>level: 로깅 상세도</li>
      <li>rotation: 파일 순환 방식</li>
      <li>max_bytes: 파일 크기 제한</li>
    </ul>
  </li>
</ul>

<h3 id="2-이벤트-로깅">2. 이벤트 로깅</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">log_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">details</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]):</span>
    <span class="s">"""이벤트 기록
    
    Parameters
    ----------
    event_type : str
        이벤트 유형
    details : dict
        이벤트 상세 정보
    """</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s">"Event: </span><span class="si">{</span><span class="n">event_type</span><span class="si">}</span><span class="s"> - </span><span class="si">{</span><span class="n">json</span><span class="p">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">details</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>시뮬레이션 이벤트 로깅
    <ul>
      <li>이벤트 유형 분류</li>
      <li>JSON 형식 상세 정보</li>
      <li>시간 자동 기록</li>
    </ul>
  </li>
</ul>

<h3 id="3-메트릭-관리">3. 메트릭 관리</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">log_metric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> 
               <span class="n">timestamp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="s">"""메트릭 기록
    
    Parameters
    ----------
    name : str
        메트릭 이름
    value : any
        메트릭 값
    timestamp : float, optional
        타임스탬프 (기본값: 현재 시간)
    """</span>
    <span class="k">if</span> <span class="n">timestamp</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">timestamp</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">().</span><span class="n">timestamp</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">metrics</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">metrics</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        
    <span class="bp">self</span><span class="p">.</span><span class="n">metrics</span><span class="p">[</span><span class="n">name</span><span class="p">].</span><span class="n">append</span><span class="p">({</span>
        <span class="s">'timestamp'</span><span class="p">:</span> <span class="n">timestamp</span><span class="p">,</span>
        <span class="s">'value'</span><span class="p">:</span> <span class="n">value</span>
    <span class="p">})</span>
</code></pre></div></div>

<ul>
  <li>시계열 메트릭 저장
    <ul>
      <li>이름 기반 분류</li>
      <li>시간 정보 포함</li>
      <li>메모리 내 저장</li>
    </ul>
  </li>
</ul>

<h3 id="4-네트워크-상태-로깅">4. 네트워크 상태 로깅</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">log_network_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cells</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">ues</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
    <span class="s">"""네트워크 상태 기록
    
    Parameters
    ----------
    cells : list
        셀 객체 리스트
    ues : list
        UE 객체 리스트
    """</span>
    <span class="n">state</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'timestamp'</span><span class="p">:</span> <span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">().</span><span class="n">timestamp</span><span class="p">(),</span>
        <span class="s">'cells'</span><span class="p">:</span> <span class="p">[{</span>
            <span class="s">'id'</span><span class="p">:</span> <span class="n">cell</span><span class="p">.</span><span class="n">i</span><span class="p">,</span>
            <span class="s">'position'</span><span class="p">:</span> <span class="n">cell</span><span class="p">.</span><span class="n">xyz</span><span class="p">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s">'active_freqs'</span><span class="p">:</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">cell</span><span class="p">.</span><span class="n">freq_config</span> 
                           <span class="k">if</span> <span class="n">cell</span><span class="p">.</span><span class="n">freq_config</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="s">'active'</span><span class="p">]],</span>
            <span class="s">'load'</span><span class="p">:</span> <span class="n">cell</span><span class="p">.</span><span class="n">get_cell_load</span><span class="p">(),</span>
            <span class="s">'energy'</span><span class="p">:</span> <span class="n">cell</span><span class="p">.</span><span class="n">get_energy_stats</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">],</span>
        <span class="s">'ues'</span><span class="p">:</span> <span class="p">[{</span>
            <span class="s">'id'</span><span class="p">:</span> <span class="n">ue</span><span class="p">.</span><span class="n">i</span><span class="p">,</span>
            <span class="s">'position'</span><span class="p">:</span> <span class="n">ue</span><span class="p">.</span><span class="n">xyz</span><span class="p">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="s">'serving_cell'</span><span class="p">:</span> <span class="n">ue</span><span class="p">.</span><span class="n">serving_cell</span><span class="p">.</span><span class="n">i</span> <span class="k">if</span> <span class="n">ue</span><span class="p">.</span><span class="n">serving_cell</span> <span class="k">else</span> <span class="bp">None</span><span class="p">,</span>
            <span class="s">'metrics'</span><span class="p">:</span> <span class="n">ue</span><span class="p">.</span><span class="n">get_metrics</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">for</span> <span class="n">ue</span> <span class="ow">in</span> <span class="n">ues</span><span class="p">]</span>
    <span class="p">}</span>
    
    <span class="bp">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s">"Network State: </span><span class="si">{</span><span class="n">json</span><span class="p">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>전체 네트워크 상태 스냅샷
    <ul>
      <li>셀 상태 정보</li>
      <li>UE 연결 정보</li>
      <li>JSON 형식 저장</li>
    </ul>
  </li>
</ul>

<h3 id="5-메트릭-시각화">5. 메트릭 시각화</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">plot_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="s">"""메트릭 플롯 생성
    
    Parameters
    ----------
    metric_names : list, optional
        플롯할 메트릭 이름 리스트 (기본값: 모든 메트릭)
    """</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
        
        <span class="k">if</span> <span class="n">metric_names</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">metric_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">keys</span><span class="p">())</span>
            
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">metric_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">metrics</span><span class="p">:</span>
                <span class="k">continue</span>
                
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">metrics</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">timestamps</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s">'timestamp'</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="s">'value'</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
            
            <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
            <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">timestamps</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
            <span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s">'Metric: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
            <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Timestamp'</span><span class="p">)</span>
            <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Value'</span><span class="p">)</span>
            <span class="n">plt</span><span class="p">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
            
            <span class="n">plot_file</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">log_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s">"metric_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">_</span><span class="si">{</span><span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">()</span><span class="si">:</span><span class="o">%</span><span class="n">Y</span><span class="o">%</span><span class="n">m</span><span class="o">%</span><span class="n">d_</span><span class="o">%</span><span class="n">H</span><span class="o">%</span><span class="n">M</span><span class="o">%</span><span class="n">S</span><span class="si">}</span><span class="s">.png"</span>
            <span class="n">plt</span><span class="p">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">plot_file</span><span class="p">)</span>
            <span class="n">plt</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
            
    <span class="k">except</span> <span class="nb">ImportError</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">warning</span><span class="p">(</span><span class="s">"matplotlib is required for plotting metrics"</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>메트릭 시각화 도구
    <ul>
      <li>matplotlib 기반 그래프</li>
      <li>시계열 플롯 생성</li>
      <li>PNG 파일 저장</li>
    </ul>
  </li>
</ul>

<h3 id="6-유틸리티-함수">6. 유틸리티 함수</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_logger</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">logging</span><span class="p">.</span><span class="n">Logger</span><span class="p">:</span>
    <span class="s">"""로거 인스턴스 반환"""</span>
    <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">logger</span>

<span class="k">def</span> <span class="nf">clear_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="s">"""메트릭 초기화"""</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">clear</span><span class="p">()</span>
</code></pre></div></div>

<ul>
  <li>logger 인스턴스 접근</li>
  <li>메트릭 데이터 관리</li>
</ul>

<h3 id="7-네트워크-시각화">7. 네트워크 시각화</h3>

<h4 id="71-주파수-대역별-커버리지-시각화">7.1 주파수 대역별 커버리지 시각화</h4>

<p>네트워크 상태를 시각적으로 표현하기 위해 <code class="language-plaintext highlighter-rouge">plot_frequency_band_coverage</code> 함수를 구현</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">plot_frequency_band_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">cells</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                               <span class="n">ues</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                               <span class="n">grid_size</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span>
                               <span class="n">save_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="s">"""주파수 대역별 커버리지 및 UE 연결 상태 시각화
    
    Parameters
    ----------
    cells : list
        셀 객체 리스트
    ues : list
        UE 객체 리스트
    grid_size : tuple
        그리드 해상도 (기본값: 200x200)
    save_path : str, optional
        저장 경로 (기본값: logs/freq_band_coverage_YYYYMMDD_HHMMSS.png)
    """</span>
</code></pre></div></div>

<ul>
  <li>
    <p>주요 컴포넌트</p>

    <ul>
      <li>주파수 대역 설정</li>
    </ul>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># 주파수 대역별 설정
</span>  <span class="n">frequency_bands</span> <span class="o">=</span> <span class="p">{</span>
      <span class="mi">800</span><span class="p">:</span> <span class="p">{</span><span class="s">'color'</span><span class="p">:</span> <span class="s">'RdYlBu_r'</span><span class="p">,</span> <span class="s">'title'</span><span class="p">:</span> <span class="s">'800 MHz Coverage'</span><span class="p">},</span>
      <span class="mi">1800</span><span class="p">:</span> <span class="p">{</span><span class="s">'color'</span><span class="p">:</span> <span class="s">'RdYlBu_r'</span><span class="p">,</span> <span class="s">'title'</span><span class="p">:</span> <span class="s">'1800 MHz Coverage'</span><span class="p">},</span>
      <span class="mi">3600</span><span class="p">:</span> <span class="p">{</span><span class="s">'color'</span><span class="p">:</span> <span class="s">'RdYlBu_r'</span><span class="p">,</span> <span class="s">'title'</span><span class="p">:</span> <span class="s">'3600 MHz Coverage'</span><span class="p">}</span>
  <span class="p">}</span>

  <span class="c1"># 셀별 색상 할당
</span>  <span class="n">cell_colors</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">cm</span><span class="p">.</span><span class="n">Set3</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells</span><span class="p">)))</span>
  <span class="n">cell_color_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">cell</span><span class="p">.</span><span class="n">i</span><span class="p">:</span> <span class="n">cell_colors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cells</span><span class="p">)}</span>
</code></pre></div>    </div>

    <ul>
      <li>커버리지 맵 생성</li>
    </ul>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># RSRP 계산
</span>  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">grid_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
          <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>
          <span class="n">max_rsrp</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s">'-inf'</span><span class="p">)</span>
            
          <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">:</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">freq</span> <span class="ow">in</span> <span class="n">cell</span><span class="p">.</span><span class="n">freq_config</span> <span class="ow">and</span> 
                  <span class="n">cell</span><span class="p">.</span><span class="n">freq_config</span><span class="p">[</span><span class="n">freq</span><span class="p">][</span><span class="s">'active'</span><span class="p">]):</span>
                  <span class="n">rsrp</span> <span class="o">=</span> <span class="n">cell</span><span class="p">.</span><span class="n">calculate_rsrp</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">freq</span><span class="p">)</span>
                  <span class="n">max_rsrp</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_rsrp</span><span class="p">,</span> <span class="n">rsrp</span><span class="p">)</span>
            
          <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_rsrp</span>

  <span class="c1"># 커버리지 맵 플로팅
</span>  <span class="n">coverage</span> <span class="o">=</span> <span class="n">ax</span><span class="p">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span>
                      <span class="n">shading</span><span class="o">=</span><span class="s">'auto'</span><span class="p">,</span>
                      <span class="n">cmap</span><span class="o">=</span><span class="n">freq_info</span><span class="p">[</span><span class="s">'color'</span><span class="p">],</span>
                      <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                      <span class="n">vmin</span><span class="o">=-</span><span class="mi">120</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=-</span><span class="mi">60</span><span class="p">)</span>
  <span class="n">plt</span><span class="p">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">coverage</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">'RSRP (dBm)'</span><span class="p">)</span>
</code></pre></div>    </div>

    <ul>
      <li>셀과 UE 시각화</li>
    </ul>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1"># 셀 표시
</span>  <span class="n">ax</span><span class="p">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="n">color</span><span class="p">],</span>
        <span class="n">marker</span><span class="o">=</span><span class="s">'^'</span><span class="p">,</span>
        <span class="n">s</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
        <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s">'Cell </span><span class="si">{</span><span class="n">cell</span><span class="p">.</span><span class="n">i</span><span class="si">}</span><span class="s">'</span><span class="p">,</span>
        <span class="n">edgecolors</span><span class="o">=</span><span class="s">'black'</span><span class="p">,</span>
        <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>

  <span class="c1"># UE 표시
</span>  <span class="n">ax</span><span class="p">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
          <span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="n">color</span><span class="p">],</span>
          <span class="n">marker</span><span class="o">=</span><span class="s">'o'</span><span class="p">,</span>
          <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
          <span class="n">edgecolors</span><span class="o">=</span><span class="s">'black'</span><span class="p">,</span>
          <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
          <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>&lt;firstname&gt; &lt;lastname&gt;</name><email>&lt;mail@domain.tld&gt;</email></author><category term="sim" /><summary type="html"><![CDATA[**Date**: 2024.12.26, **Tag**: [Offloading], [Patent], [Multi Frequency Band]]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/blog/sim/phase1/sim.png" /><media:content medium="image" url="http://localhost:4000/assets/img/blog/sim/phase1/sim.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">오프로딩 시뮬레이터 - Helper</title><link href="http://localhost:4000/blog/sim/2024-12-26-offloading-helper/" rel="alternate" type="text/html" title="오프로딩 시뮬레이터 - Helper" /><published>2024-12-26T00:00:00+09:00</published><updated>2024-12-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/sim/offloading-helper</id><content type="html" xml:base="http://localhost:4000/blog/sim/2024-12-26-offloading-helper/"><![CDATA[<!--more-->

<ul class="large-only" id="markdown-toc">
  <li><a href="#5g-셀-시뮬레이터-구현-가이드-utilshleperpy" id="markdown-toc-5g-셀-시뮬레이터-구현-가이드-utilshleperpy">5G 셀 시뮬레이터 구현 가이드: <code class="language-plaintext highlighter-rouge">utils/hleper.py</code></a>    <ul>
      <li><a href="#1-아키텍쳐-개요" id="markdown-toc-1-아키텍쳐-개요">1. 아키텍쳐 개요</a></li>
      <li><a href="#2-코드-설명" id="markdown-toc-2-코드-설명">2. 코드 설명</a>        <ul>
          <li><a href="#1-logger-setup" id="markdown-toc-1-logger-setup">1. Logger Setup</a></li>
          <li><a href="#2-geometric-utilities" id="markdown-toc-2-geometric-utilities">2. Geometric Utilities</a></li>
          <li><a href="#3-signal-processing" id="markdown-toc-3-signal-processing">3. Signal Processing</a></li>
          <li><a href="#4-data-management" id="markdown-toc-4-data-management">4. Data Management</a></li>
          <li><a href="#5-network-analysis" id="markdown-toc-5-network-analysis">5. Network Analysis</a></li>
          <li><a href="#6-grid-generation" id="markdown-toc-6-grid-generation">6. Grid Generation</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="5g-셀-시뮬레이터-구현-가이드-utilshleperpy">5G 셀 시뮬레이터 구현 가이드: <code class="language-plaintext highlighter-rouge">utils/hleper.py</code></h1>

<h2 id="1-아키텍쳐-개요">1. 아키텍쳐 개요</h2>

<p>helpers.py는 시뮬레이터 전반에서 사용되는 유틸리티 함수들을 제공함. 이 모듈은 다음과 같은 주요 컴포넌트들로 구성되어 있음.</p>

<ul>
  <li>Logger Setup: 로깅 시스템 설정 및 관리</li>
  <li>Geometric Utilities: 3D 공간에서의 기하학적 계산</li>
  <li>Signal Processing: 신호 처리 관련 유틸리티</li>
  <li>Data Management: 데이터 저장 및 로드 기능</li>
  <li>Network Analysis: 네트워크 성능 분석 도구</li>
  <li>Grid Generation: 시뮬레이션 영역 내 위치 생성</li>
</ul>

<h2 id="2-코드-설명">2. 코드 설명</h2>

<h3 id="1-logger-setup">1. Logger Setup</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">setup_logger</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">'INFO'</span><span class="p">,</span>
                <span class="n">log_file</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">logging</span><span class="p">.</span><span class="n">Logger</span><span class="p">:</span>
    <span class="s">"""로깅 설정
    
    Parameters
    ----------
    name : str
        로거 이름
    level : str
        로깅 레벨 ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL')
    log_file : str, optional
        로그 파일 경로
        
    Returns
    -------
    logging.Logger
        설정된 로거 인스턴스
    """</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">setup_logger</code>: 로깅 시스템 초기화
    <ul>
      <li>name: logger 이름 지정</li>
      <li>level: logging 레벨 설정</li>
      <li>log_fie: 파일 출력 설정</li>
      <li>파일과 콘솔 동시 출력 지원</li>
    </ul>
  </li>
</ul>

<h3 id="2-geometric-utilities">2. Geometric Utilities</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">calculate_distance</span><span class="p">(</span><span class="n">point1</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
                      <span class="n">point2</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">point1</span> <span class="o">-</span> <span class="n">point2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">calculate_angle</span><span class="p">(</span><span class="n">point1</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span>
                   <span class="n">point2</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">point2</span> <span class="o">-</span> <span class="n">point1</span>
    <span class="n">azimuth</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">diff</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">diff</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">r_xy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">diff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">elevation</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">diff</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">r_xy</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">azimuth</span><span class="p">,</span> <span class="n">elevation</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">calculate_distance</code>: 3D 유클리드 거리 계산
    <ul>
      <li>numpy 배열 기반 효율적 계산</li>
      <li>벡터화 연산 지원</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">calculate_angle</code>: 방위각과 고도각 계산
    <ul>
      <li>azimuth: XY평면에서의 각도</li>
      <li>elevation: XY평면과 Z축 사이의 각도</li>
      <li>라디안 단위 변환</li>
    </ul>
  </li>
</ul>

<h3 id="3-signal-processing">3. Signal Processing</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">db_to_linear</span><span class="p">(</span><span class="n">db_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="n">db_value</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">linear_to_db</span><span class="p">(</span><span class="n">linear_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">log10</span><span class="p">(</span><span class="n">linear_value</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">calculate_throughput</span><span class="p">(</span><span class="n">sinr</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                        <span class="n">bandwidth</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                        <span class="n">efficiency</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="n">capacity</span> <span class="o">=</span> <span class="n">bandwidth</span> <span class="o">*</span> <span class="n">efficiency</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="n">log2</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">db_to_linear</span><span class="p">(</span><span class="n">sinr</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">capacity</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">db_to_linear</code>, <code class="language-plaintext highlighter-rouge">linear_to_db</code>: 단위 변환
    <ul>
      <li>dB 값과 선형 값 사이의 변환</li>
      <li>로그 스케일 처리</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">calculate_throughput</code>: 처리량 계산
    <ul>
      <li>SINR: Signal-to-Interference-and-Noise Ratio (dB)</li>
      <li>bandwidth: 대역폭 (Hz)</li>
      <li>efficiency: 스펙트럼 효율성 (0-1)</li>
      <li>Shannon capacity formula 이용</li>
    </ul>
  </li>
</ul>

<h3 id="4-data-management">4. Data Management</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">save_results</span><span class="p">(</span><span class="n">results</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
                <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="s">"""시뮬레이션 결과를 JSON 형식으로 저장
    
    Parameters
    ----------
    results : dict
        저장할 결과 데이터
    filepath : str
        저장 경로. '.json' 확장자가 없으면 자동으로 추가
    """</span>
    <span class="k">def</span> <span class="nf">convert_numpy</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span><span class="p">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">convert_numpy</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">convert_numpy</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">obj</span>
    
    <span class="c1"># NumPy 배열을 리스트로 변환
</span>    <span class="n">results</span> <span class="o">=</span> <span class="n">convert_numpy</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
    
    <span class="c1"># 파일 경로 처리
</span>    <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path</span><span class="p">.</span><span class="n">suffix</span> <span class="o">!=</span> <span class="s">'.json'</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s">'.json'</span><span class="p">)</span>
    
    <span class="c1"># 부모 디렉토리 생성
</span>    <span class="n">path</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    
    <span class="c1"># JSON 파일로 저장
</span>    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">'w'</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">'utf-8'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">json</span><span class="p">.</span><span class="n">dump</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">load_results</span><span class="p">(</span><span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
    <span class="s">"""JSON 형식의 시뮬레이션 결과 로드
    
    Parameters
    ----------
    filepath : str
        로드할 파일 경로
        
    Returns
    -------
    dict
        결과 데이터
    """</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path</span><span class="p">.</span><span class="n">suffix</span> <span class="o">!=</span> <span class="s">'.json'</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s">'.json'</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="p">.</span><span class="n">exists</span><span class="p">():</span>
        <span class="k">raise</span> <span class="nb">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s">"결과 파일을 찾을 수 없습니다: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">'r'</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">'utf-8'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">json</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">save_results</code>: 시뮬레이션 결과 저장</p>

    <ul>
      <li>NumPy 배열 자동 변환</li>
      <li>JSON 형식으로 저장</li>
      <li>디렉토리 자동 생성</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">load_results</code>: 저장된 결과 로드</p>

    <ul>
      <li>JSON 파일 로드</li>
      <li>파일 존재 여부 검증</li>
    </ul>
  </li>
</ul>

<h3 id="5-network-analysis">5. Network Analysis</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">calculate_network_metrics</span><span class="p">(</span><span class="n">cells</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
                            <span class="n">ues</span><span class="p">:</span> <span class="n">List</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
    <span class="n">metrics</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'network_load'</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s">'total_throughput'</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s">'average_latency'</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s">'energy_consumption'</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s">'user_satisfaction'</span><span class="p">:</span> <span class="mi">0</span>
    <span class="p">}</span>
    
    <span class="n">active_cells</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">:</span>
        <span class="n">cell_metrics</span> <span class="o">=</span> <span class="n">cell</span><span class="p">.</span><span class="n">get_metrics</span><span class="p">()</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s">'network_load'</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cell_metrics</span><span class="p">[</span><span class="s">'load'</span><span class="p">]</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s">'total_throughput'</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cell_metrics</span><span class="p">[</span><span class="s">'throughput'</span><span class="p">]</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s">'energy_consumption'</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cell_metrics</span><span class="p">[</span><span class="s">'energy'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cell_metrics</span><span class="p">[</span><span class="s">'load'</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">active_cells</span> <span class="o">+=</span> <span class="mi">1</span>
            
    <span class="k">if</span> <span class="n">active_cells</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s">'network_load'</span><span class="p">]</span> <span class="o">/=</span> <span class="n">active_cells</span>

    <span class="n">satisfied_users</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">ue</span> <span class="ow">in</span> <span class="n">ues</span> <span class="k">if</span> <span class="n">ue</span><span class="p">.</span><span class="n">get_qos_satisfaction</span><span class="p">()[</span><span class="s">'throughput'</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">ues</span><span class="p">:</span>
        <span class="n">metrics</span><span class="p">[</span><span class="s">'user_satisfaction'</span><span class="p">]</span> <span class="o">=</span> <span class="n">satisfied_users</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">ues</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">metrics</span>
</code></pre></div></div>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">calculate_network_metrics</code>: 네트워크 전체 성능 분석</p>

    <ul>
      <li>전체 네타워크 부하 계산</li>
      <li>처리량 및 에너지 소비 분석</li>
      <li>QoS 만족도 평가</li>
    </ul>
  </li>
</ul>

<h3 id="6-grid-generation">6. Grid Generation</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">generate_grid_positions</span><span class="p">(</span><span class="n">area_bounds</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">],</span>
                          <span class="n">n_points</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">n_per_dim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n_points</span><span class="p">)))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">area_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">area_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">n_per_dim</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">area_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">area_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_per_dim</span><span class="p">)</span>
    
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">stack</span><span class="p">([</span><span class="n">X</span><span class="p">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">Y</span><span class="p">.</span><span class="n">flatten</span><span class="p">(),</span> 
                         <span class="n">np</span><span class="p">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">flatten</span><span class="p">())],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">positions</span><span class="p">[:</span><span class="n">n_points</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">generate_timestamp</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">().</span><span class="n">strftime</span><span class="p">(</span><span class="s">'%Y%m%d_%H%M%S'</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">generate_grid_positions</code>: 균일 그리드 위치 생성
    <ul>
      <li>area_bounds: 시뮬레이션 영역 경계</li>
      <li>n_points: 생성할 포인트 수</li>
      <li>2D 평면에 균일하게 분포된 위치 생성</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">generate_timestamp</code>: 타임스탬프 생성
    <ul>
      <li>YYYYMMDD_HHMMSS 형식</li>
      <li>파일명이나 로그에 사용</li>
    </ul>
  </li>
</ul>]]></content><author><name>&lt;firstname&gt; &lt;lastname&gt;</name><email>&lt;mail@domain.tld&gt;</email></author><category term="sim" /><summary type="html"><![CDATA[**Date**: 2024.12.26, **Tag**: [Offloading], [Patent], [Multi Frequency Band]]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/blog/sim/phase1/sim.png" /><media:content medium="image" url="http://localhost:4000/assets/img/blog/sim/phase1/sim.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">오프로딩 시뮬레이터 - Cell</title><link href="http://localhost:4000/blog/sim/2024-12-24-offloading-cell/" rel="alternate" type="text/html" title="오프로딩 시뮬레이터 - Cell" /><published>2024-12-24T00:00:00+09:00</published><updated>2024-12-24T00:00:00+09:00</updated><id>http://localhost:4000/blog/sim/offloading-cell</id><content type="html" xml:base="http://localhost:4000/blog/sim/2024-12-24-offloading-cell/"><![CDATA[<!--more-->

<ul class="large-only" id="markdown-toc">
  <li><a href="#5g-셀-시뮬레이터-구현-가이드-cellpy" id="markdown-toc-5g-셀-시뮬레이터-구현-가이드-cellpy">5G 셀 시뮬레이터 구현 가이드: <code class="language-plaintext highlighter-rouge">cell.py</code></a></li>
  <li><a href="#5g-셀-시뮬레이터-구현-가이드-componentscellpy" id="markdown-toc-5g-셀-시뮬레이터-구현-가이드-componentscellpy">5G 셀 시뮬레이터 구현 가이드: <code class="language-plaintext highlighter-rouge">components/cell.py</code></a>    <ul>
      <li><a href="#1-아키텍쳐-개요" id="markdown-toc-1-아키텍쳐-개요">1. 아키텍쳐 개요</a>        <ul>
          <li><a href="#11-설계-철학" id="markdown-toc-11-설계-철학">1.1 설계 철학</a>            <ul>
              <li><a href="#1-클래스-초기화" id="markdown-toc-1-클래스-초기화">1. 클래스 초기화</a></li>
              <li><a href="#2-주파수-설정" id="markdown-toc-2-주파수-설정">2. 주파수 설정</a></li>
              <li><a href="#3-트래픽-예측" id="markdown-toc-3-트래픽-예측">3. 트래픽 예측</a></li>
              <li><a href="#4-에너지-소비-관리" id="markdown-toc-4-에너지-소비-관리">4. 에너지 소비 관리</a></li>
              <li><a href="#5-셀-상태-관리" id="markdown-toc-5-셀-상태-관리">5. 셀 상태 관리</a></li>
              <li><a href="#6-성능-측정-및-보고" id="markdown-toc-6-성능-측정-및-보고">6. 성능 측정 및 보고</a></li>
              <li><a href="#7-참고문헌" id="markdown-toc-7-참고문헌">7. 참고문헌</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>«««&lt; HEAD</p>
<h1 id="5g-셀-시뮬레이터-구현-가이드-cellpy">5G 셀 시뮬레이터 구현 가이드: <code class="language-plaintext highlighter-rouge">cell.py</code></h1>
<p>=======</p>
<h1 id="5g-셀-시뮬레이터-구현-가이드-componentscellpy">5G 셀 시뮬레이터 구현 가이드: <code class="language-plaintext highlighter-rouge">components/cell.py</code></h1>
<blockquote>
  <blockquote>
    <blockquote>
      <blockquote>
        <blockquote>
          <blockquote>
            <blockquote>
              <p>c9b4b85b73d42fdc5a945dcab7b288650d40921f</p>
            </blockquote>
          </blockquote>
        </blockquote>
      </blockquote>
    </blockquote>
  </blockquote>
</blockquote>

<h2 id="1-아키텍쳐-개요">1. 아키텍쳐 개요</h2>

<h3 id="11-설계-철학">1.1 설계 철학</h3>
<ul>
  <li>실제 5G 기지국의 동작을 최대한 유사하게 모사</li>
  <li>트래픽 예측을 통한 선제적 자원 관리</li>
  <li>에너지 효율적인 운영</li>
  <li>다중 주파수 대역 지원</li>
  <li>QoS 기반 사용자 관리</li>
</ul>

<h4 id="1-클래스-초기화">1. 클래스 초기화</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">h_BS</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span> 
             <span class="n">MIMO_gain_dB</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">f_callback</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> 
             <span class="n">f_callback_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="n">Cell</span><span class="p">.</span><span class="n">i</span>
    <span class="n">Cell</span><span class="p">.</span><span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">sim</span> <span class="o">=</span> <span class="n">sim</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">interval</span> <span class="o">=</span> <span class="n">interval</span>
    
    <span class="c1"># 트래픽 예측 관련 설정
</span>    <span class="bp">self</span><span class="p">.</span><span class="n">traffic_predictor</span> <span class="o">=</span> <span class="n">ProphetPredictor</span><span class="p">()</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">traffic_db</span> <span class="o">=</span> <span class="n">TimeseriesDB</span><span class="p">()</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">prediction_horizon</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># 10초 (1초 * 10)
</span></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sim</code>: 메인 시뮬레이터 인스턴스를 전달받음. 이를 통해 전체 시뮬레이션 환경에 접근할 수 있음</li>
  <li><code class="language-plaintext highlighter-rouge">interval</code>: 셀의 상태 업데이트 주기를 설정. 기본값은 1초</li>
  <li><code class="language-plaintext highlighter-rouge">traffic_predictor</code>: 트래픽 예측기를 초기화</li>
  <li><code class="language-plaintext highlighter-rouge">prediction_horizon</code>: 10으로 설정하여 10초 앞의 트래픽을 예측</li>
</ul>

<p class="note">중요 포인트</p>
<ul>
  <li>Cell.i는 셀 식별자로 사용되며, 생성될 때마다 자동으로 증가한다.</li>
  <li>ProphetPredictor는 별도의 클래스로 구현되어 있으며, 시계열 예측을 담당한다.</li>
</ul>

<h4 id="2-주파수-설정">2. 주파수 설정</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 주파수 설정
</span><span class="bp">self</span><span class="p">.</span><span class="n">freq_config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">800</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'bandwidth'</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">,</span>  <span class="c1"># MHz
</span>        <span class="s">'n_RBs'</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span>       <span class="c1"># Resource Blocks
</span>        <span class="s">'active'</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
        <span class="s">'energy_consumed'</span><span class="p">:</span> <span class="mf">0.0</span>
    <span class="p">},</span>
    <span class="mi">1800</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'bandwidth'</span><span class="p">:</span> <span class="mf">20.0</span><span class="p">,</span>
        <span class="s">'n_RBs'</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s">'active'</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
        <span class="s">'energy_consumed'</span><span class="p">:</span> <span class="mf">0.0</span>
    <span class="p">},</span>
    <span class="mi">3600</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'bandwidth'</span><span class="p">:</span> <span class="mf">100.0</span><span class="p">,</span>
        <span class="s">'n_RBs'</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
        <span class="s">'active'</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
        <span class="s">'energy_consumed'</span><span class="p">:</span> <span class="mf">0.0</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>각 주파수 대역별로 다음 파라미터를 설정
    <ul>
      <li><code class="language-plaintext highlighter-rouge">bandwidth</code>: MHz</li>
      <li><code class="language-plaintext highlighter-rouge">n_RBs</code>: Resource Block 수</li>
      <li><code class="language-plaintext highlighter-rouge">active</code>: 활성화 여부</li>
      <li><code class="language-plaintext highlighter-rouge">energy_consumed</code>: 에너지 소비량</li>
    </ul>
  </li>
</ul>

<p class="note">중요 포인트</p>
<ul>
  <li>800MHz: 커버리지가 넓지만 용량이 적음</li>
  <li>1800MHz: 중간 대역으로 커버리지와 용량의 균형을 제공</li>
  <li>3600MHz: mmWave 대역으로 높은 용량을 제공하지만 커버리지가 제한적</li>
</ul>

<h4 id="3-트래픽-예측">3. 트래픽 예측</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">predict_traffic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">traffic_history</span><span class="p">[</span><span class="n">freq</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>  <span class="c1"># 최소 10초의 데이터 필요
</span>        <span class="k">return</span> <span class="bp">None</span>
        
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">DataFrame</span><span class="p">({</span>
        <span class="s">'ds'</span><span class="p">:</span> <span class="n">pd</span><span class="p">.</span><span class="n">date_range</span><span class="p">(</span><span class="n">end</span><span class="o">=</span><span class="n">pd</span><span class="p">.</span><span class="n">Timestamp</span><span class="p">.</span><span class="n">now</span><span class="p">(),</span> 
                          <span class="n">periods</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">traffic_history</span><span class="p">[</span><span class="n">freq</span><span class="p">]),</span> 
                          <span class="n">freq</span><span class="o">=</span><span class="s">'15T'</span><span class="p">),</span>
        <span class="s">'y'</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">traffic_history</span><span class="p">[</span><span class="n">freq</span><span class="p">]</span>
    <span class="p">})</span>
    
    <span class="bp">self</span><span class="p">.</span><span class="n">traffic_predictor</span><span class="p">.</span><span class="n">train</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">forecast</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">traffic_predictor</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">prediction_horizon</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">forecast</span><span class="p">[</span><span class="s">'yhat'</span><span class="p">].</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">traffic_history</code>: 각 주파수별 트래픽 이력을 저장</li>
  <li>최소 10초(10개의 샘플)의 데이터가 필요</li>
  <li>Prophet 모델의 입력 형식에 맞게 DataFrame을 구성</li>
  <li>예측 결과의 마지막 값을 반환</li>
</ul>

<p class="note">중요 포인트</p>
<ul>
  <li>Prophet 모델은 <code class="language-plaintext highlighter-rouge">ds</code>와 <code class="language-plaintext highlighter-rouge">y</code> 컬럼을 필요로 함</li>
  <li>10초 간격으로 데이터를 샘플링</li>
  <li>예측값이 없는 경우 None을 반환</li>
</ul>

<h4 id="4-에너지-소비-관리">4. 에너지 소비 관리</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">update_energy_consumption</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">interval_hours</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">interval</span> <span class="o">/</span> <span class="mi">3600</span>  <span class="c1"># 초를 시간으로 변환
</span>    <span class="n">energy</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">base_power_W</span> <span class="o">*</span> <span class="n">interval_hours</span>
    
    <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">freq_config</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">freq_config</span><span class="p">[</span><span class="n">freq</span><span class="p">][</span><span class="s">'active'</span><span class="p">]:</span>
            <span class="n">freq_energy</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">frequency_power_W</span> <span class="o">*</span> <span class="n">interval_hours</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">freq_config</span><span class="p">[</span><span class="n">freq</span><span class="p">][</span><span class="s">'energy_consumed'</span><span class="p">]</span> <span class="o">+=</span> <span class="n">freq_energy</span>
            <span class="n">energy</span> <span class="o">+=</span> <span class="n">freq_energy</span>
            
    <span class="bp">self</span><span class="p">.</span><span class="n">total_energy_consumed</span> <span class="o">+=</span> <span class="n">energy</span>
</code></pre></div></div>
<ul>
  <li>기본 전력 소비(<code class="language-plaintext highlighter-rouge">base_power_W</code>)와 주파수별 추가 전력 소비를 계산</li>
  <li>시간 단위로 변환하여 에너지 소비량을 계산</li>
  <li>각 주파수 대역별 에너지 소비를 누적하여 기록</li>
</ul>

<p class="note">중요 포인트</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">interval_hours</code>: 초 단위를 시간 단위로 변환</li>
  <li><code class="language-plaintext highlighter-rouge">base_power_W</code>: 기본 소비 전력 (130W)</li>
  <li><code class="language-plaintext highlighter-rouge">frequency_power_W</code>: 주파수 당 추가 소비 전력 (100W)</li>
</ul>

<h4 id="5-셀-상태-관리">5. 셀 상태 관리</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">manage_cell_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">freq_config</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">freq_config</span><span class="p">[</span><span class="n">freq</span><span class="p">][</span><span class="s">'active'</span><span class="p">]:</span>
            <span class="k">continue</span>
            
        <span class="n">current_load</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_frequency_load</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="n">predicted_load</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">predict_traffic</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">predicted_load</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">continue</span>
            
        <span class="k">if</span> <span class="p">(</span><span class="n">current_load</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">traffic_thresholds</span><span class="p">[</span><span class="n">freq</span><span class="p">][</span><span class="s">'low'</span><span class="p">]</span> <span class="ow">and</span> 
            <span class="n">predicted_load</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">traffic_thresholds</span><span class="p">[</span><span class="n">freq</span><span class="p">][</span><span class="s">'low'</span><span class="p">]):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">can_shift_traffic</span><span class="p">(</span><span class="n">freq</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">deactivate_frequency</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">redistribute_traffic</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">current_load</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">traffic_thresholds</span><span class="p">[</span><span class="n">freq</span><span class="p">][</span><span class="s">'high'</span><span class="p">]</span> <span class="ow">or</span> 
              <span class="n">predicted_load</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">traffic_thresholds</span><span class="p">[</span><span class="n">freq</span><span class="p">][</span><span class="s">'high'</span><span class="p">]):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">activate_frequency</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>각 주파수 대역의 현재 부하와 예측 부하를 확인</li>
  <li>트래픽 임계값을 기준으로 주파수 활성화/비활성화를 결정</li>
  <li>트래픽 재분배 가능 여부를 확인 후 실행</li>
</ul>

<ul class="note">
  <li><code class="language-plaintext highlighter-rouge">traffic_thresholds</code>: 주파수별 저부하/고부하 임계값</li>
  <li><code class="language-plaintext highlighter-rouge">can_shift_traffic</code>: 트래픽 재분배 가능 여부를 확인하고, 분배 가능 여부을 반환</li>
  <li><code class="language-plaintext highlighter-rouge">redistribute_traffic</code>: 실제 트래픽 재분배를 수행</li>
</ul>

<h4 id="6-성능-측정-및-보고">6. 성능 측정 및 보고</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s">'throughput'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">'current'</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">metrics</span><span class="p">[</span><span class="s">'throughput'</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">metrics</span><span class="p">[</span><span class="s">'throughput'</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s">'average'</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">metrics</span><span class="p">[</span><span class="s">'throughput'</span><span class="p">])</span> <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">metrics</span><span class="p">[</span><span class="s">'throughput'</span><span class="p">]</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="p">},</span>
        <span class="s">'energy'</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_energy_stats</span><span class="p">(),</span>
        <span class="s">'load'</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">freq</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_frequency_load</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">freq_config</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>처리량, 에너지 소비, 부하 등의 주요 성능 지표를 수집</li>
  <li>현재값과 평균값을 함께 제공</li>
  <li>주파수별 세부 통계를 포함</li>
</ul>

<p class="note">중요 포인트</p>
<ul>
  <li>처리량은 가장 최근값과 평균값을 제공</li>
  <li>에너지 통계는 총 소비량과 주파수별 소비량 포함</li>
  <li>부하는 각 주파수 대역별로 계산</li>
</ul>

<h4 id="7-참고문헌">7. 참고문헌</h4>
<ol>
  <li>Path Loss Models: 3GPP TR 38.901</li>
  <li>QoS 관리: 3GPP TS 23.501</li>
  <li>주파수 자원 관리: TS 38.211</li>
</ol>]]></content><author><name>&lt;firstname&gt; &lt;lastname&gt;</name><email>&lt;mail@domain.tld&gt;</email></author><category term="sim" /><summary type="html"><![CDATA[**Date**: 2024.12.24, **Tag**: [Offloading], [Patent], [Multi Frequency Band]]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/img/blog/sim/phase1/sim.png" /><media:content medium="image" url="http://localhost:4000/assets/img/blog/sim/phase1/sim.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>